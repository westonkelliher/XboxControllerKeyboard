<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Device handling and enumeration</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="libusb.png"/></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">A cross-platform user library to access USB devices</div>
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Device handling and enumeration</div>  </div>
</div><!--header-->
<div class="contents">

<p>The functionality documented below is designed to help with the following operations:  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga77eedd00d01eb7569b880e861a971c2b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a></td></tr>
<tr class="memdesc:ga77eedd00d01eb7569b880e861a971c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing a USB device detected on the system.  <a href="#ga77eedd00d01eb7569b880e861a971c2b">More...</a><br /></td></tr>
<tr class="separator:ga77eedd00d01eb7569b880e861a971c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7df95821d20d27b5597f1d783749d6a4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a></td></tr>
<tr class="memdesc:ga7df95821d20d27b5597f1d783749d6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing a handle on a USB device.  <a href="#ga7df95821d20d27b5597f1d783749d6a4">More...</a><br /></td></tr>
<tr class="separator:ga7df95821d20d27b5597f1d783749d6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2959abf1184f87b2ce06fe90db6ce614"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#ga2959abf1184f87b2ce06fe90db6ce614">libusb_speed</a> { <br />
&#160;&#160;<a class="el" href="group__libusb__dev.html#gga2959abf1184f87b2ce06fe90db6ce614ace31df1e97e9a66146ac83dcab1e6cfb">LIBUSB_SPEED_UNKNOWN</a> = 0, 
<a class="el" href="group__libusb__dev.html#gga2959abf1184f87b2ce06fe90db6ce614a6017f9ac2509cd523b51c1b72ad6991b">LIBUSB_SPEED_LOW</a> = 1, 
<a class="el" href="group__libusb__dev.html#gga2959abf1184f87b2ce06fe90db6ce614a0011bead7a48b873808795d8495b4d9e">LIBUSB_SPEED_FULL</a> = 2, 
<a class="el" href="group__libusb__dev.html#gga2959abf1184f87b2ce06fe90db6ce614a27bc0b9fe76f8ddf524f3d2ece0eefac">LIBUSB_SPEED_HIGH</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__libusb__dev.html#gga2959abf1184f87b2ce06fe90db6ce614ab8c71e1409cd555ae05937b4db9946a2">LIBUSB_SPEED_SUPER</a> = 4, 
<a class="el" href="group__libusb__dev.html#gga2959abf1184f87b2ce06fe90db6ce614aa65f23e14e68162a142f26dac5fcfc4a">LIBUSB_SPEED_SUPER_PLUS</a> = 5
<br />
 }<tr class="memdesc:ga2959abf1184f87b2ce06fe90db6ce614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Speed codes.  <a href="group__libusb__dev.html#ga2959abf1184f87b2ce06fe90db6ce614">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga2959abf1184f87b2ce06fe90db6ce614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1454797ecc0de4d084c1619c420014f6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#ga1454797ecc0de4d084c1619c420014f6">libusb_supported_speed</a> { <a class="el" href="group__libusb__dev.html#gga1454797ecc0de4d084c1619c420014f6aa7707c4cef77f4be8aceef859fad2087">LIBUSB_LOW_SPEED_OPERATION</a> = 1, 
<a class="el" href="group__libusb__dev.html#gga1454797ecc0de4d084c1619c420014f6adbebc659daf53947527259172f81b41a">LIBUSB_FULL_SPEED_OPERATION</a> = 2, 
<a class="el" href="group__libusb__dev.html#gga1454797ecc0de4d084c1619c420014f6a2db8b2bb845a23ad1083521ff5b6e9a8">LIBUSB_HIGH_SPEED_OPERATION</a> = 4, 
<a class="el" href="group__libusb__dev.html#gga1454797ecc0de4d084c1619c420014f6accd7b9361912b76e40348dc30e6dc7f4">LIBUSB_SUPER_SPEED_OPERATION</a> = 8
 }<tr class="memdesc:ga1454797ecc0de4d084c1619c420014f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported speeds (wSpeedSupported) bitfield.  <a href="group__libusb__dev.html#ga1454797ecc0de4d084c1619c420014f6">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga1454797ecc0de4d084c1619c420014f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb8cfa928bffdd0066a3dd2e6aba0558"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#gacb8cfa928bffdd0066a3dd2e6aba0558">libusb_usb_2_0_extension_attributes</a> { <a class="el" href="group__libusb__dev.html#ggacb8cfa928bffdd0066a3dd2e6aba0558a02f60b018f4bc01e8813da813779b792">LIBUSB_BM_LPM_SUPPORT</a> = 2
 }<tr class="memdesc:gacb8cfa928bffdd0066a3dd2e6aba0558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masks for the bits of the <a class="el" href="structlibusb__usb__2__0__extension__descriptor.html#ab22e1857d38c9205aaecca52b2e20ae0">bmAttributes</a> field of the USB 2.0 Extension descriptor.  <a href="group__libusb__dev.html#gacb8cfa928bffdd0066a3dd2e6aba0558">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gacb8cfa928bffdd0066a3dd2e6aba0558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad5a5399176a35a64164dafad7fe4fcd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#gaad5a5399176a35a64164dafad7fe4fcd">libusb_ss_usb_device_capability_attributes</a> { <a class="el" href="group__libusb__dev.html#ggaad5a5399176a35a64164dafad7fe4fcda5987a17b394338df71c1e04c5c75bc21">LIBUSB_BM_LTM_SUPPORT</a> = 2
 }<tr class="memdesc:gaad5a5399176a35a64164dafad7fe4fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masks for the bits of the <a class="el" href="structlibusb__ss__usb__device__capability__descriptor.html#ad387790c14d8d6eefe6aa1b4a55006bf">bmAttributes</a> field field of the SuperSpeed USB Device Capability descriptor.  <a href="group__libusb__dev.html#gaad5a5399176a35a64164dafad7fe4fcd">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gaad5a5399176a35a64164dafad7fe4fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ccabbf3b3728ae69608ba83bba4e64c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#ga6ccabbf3b3728ae69608ba83bba4e64c">libusb_bos_type</a> { <a class="el" href="group__libusb__dev.html#gga6ccabbf3b3728ae69608ba83bba4e64cac05dcfcd0a5c0dbaef90b1d09e4b5505">LIBUSB_BT_WIRELESS_USB_DEVICE_CAPABILITY</a> = 1, 
<a class="el" href="group__libusb__dev.html#gga6ccabbf3b3728ae69608ba83bba4e64ca243b090db95a0fdf7104fbf581724b86">LIBUSB_BT_USB_2_0_EXTENSION</a> = 2, 
<a class="el" href="group__libusb__dev.html#gga6ccabbf3b3728ae69608ba83bba4e64ca2f1ab0d2d1e14d4942c079749b1b6c85">LIBUSB_BT_SS_USB_DEVICE_CAPABILITY</a> = 3, 
<a class="el" href="group__libusb__dev.html#gga6ccabbf3b3728ae69608ba83bba4e64cac3c00e8861b4b596ea1f53c505809e5e">LIBUSB_BT_CONTAINER_ID</a> = 4
 }<tr class="memdesc:ga6ccabbf3b3728ae69608ba83bba4e64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB capability types.  <a href="group__libusb__dev.html#ga6ccabbf3b3728ae69608ba83bba4e64c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga6ccabbf3b3728ae69608ba83bba4e64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac0fe4b65914c5ed036e6cbec61cb0b97"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97">libusb_get_device_list</a> (<a class="el" href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a> *ctx, <a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> ***list)</td></tr>
<tr class="memdesc:gac0fe4b65914c5ed036e6cbec61cb0b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of USB devices currently attached to the system.  <a href="#gac0fe4b65914c5ed036e6cbec61cb0b97">More...</a><br /></td></tr>
<tr class="separator:gac0fe4b65914c5ed036e6cbec61cb0b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3b8561d064bb3e1b8851ddeed3cd7d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6">libusb_free_device_list</a> (<a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> **list, int unref_devices)</td></tr>
<tr class="memdesc:gad3b8561d064bb3e1b8851ddeed3cd7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a list of devices previously discovered using <a class="el" href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97" title="Returns a list of USB devices currently attached to the system. ">libusb_get_device_list()</a>.  <a href="#gad3b8561d064bb3e1b8851ddeed3cd7d6">More...</a><br /></td></tr>
<tr class="separator:gad3b8561d064bb3e1b8851ddeed3cd7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2718609d50c8ded2704e4051b3d2925"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#gaf2718609d50c8ded2704e4051b3d2925">libusb_get_bus_number</a> (<a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *dev)</td></tr>
<tr class="memdesc:gaf2718609d50c8ded2704e4051b3d2925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of the bus that a device is connected to.  <a href="#gaf2718609d50c8ded2704e4051b3d2925">More...</a><br /></td></tr>
<tr class="separator:gaf2718609d50c8ded2704e4051b3d2925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14879a0ea7daccdcddb68852d86c00c4"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#ga14879a0ea7daccdcddb68852d86c00c4">libusb_get_port_number</a> (<a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *dev)</td></tr>
<tr class="memdesc:ga14879a0ea7daccdcddb68852d86c00c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of the port that a device is connected to.  <a href="#ga14879a0ea7daccdcddb68852d86c00c4">More...</a><br /></td></tr>
<tr class="separator:ga14879a0ea7daccdcddb68852d86c00c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4b7b2b50a9ce2aa396b0af2b979544d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#gaa4b7b2b50a9ce2aa396b0af2b979544d">libusb_get_port_numbers</a> (<a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *dev, uint8_t *port_numbers, int port_numbers_len)</td></tr>
<tr class="memdesc:gaa4b7b2b50a9ce2aa396b0af2b979544d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of all port numbers from root for the specified device.  <a href="#gaa4b7b2b50a9ce2aa396b0af2b979544d">More...</a><br /></td></tr>
<tr class="separator:gaa4b7b2b50a9ce2aa396b0af2b979544d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d392b8dff7abf5e475c72fd071c3c34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9d392b8dff7abf5e475c72fd071c3c34"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#ga9d392b8dff7abf5e475c72fd071c3c34">libusb_get_port_path</a> (<a class="el" href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a> *ctx, <a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *dev, uint8_t *port_numbers, uint8_t port_numbers_len)</td></tr>
<tr class="memdesc:ga9d392b8dff7abf5e475c72fd071c3c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated please use libusb_get_port_numbers instead. <br /></td></tr>
<tr class="separator:ga9d392b8dff7abf5e475c72fd071c3c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97bb4dfff6bbb897ed9dfd6fa1a1deed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#ga97bb4dfff6bbb897ed9dfd6fa1a1deed">libusb_get_parent</a> (<a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *dev)</td></tr>
<tr class="memdesc:ga97bb4dfff6bbb897ed9dfd6fa1a1deed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the the parent from the specified device.  <a href="#ga97bb4dfff6bbb897ed9dfd6fa1a1deed">More...</a><br /></td></tr>
<tr class="separator:ga97bb4dfff6bbb897ed9dfd6fa1a1deed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d4e39ac483ebaeb108f2954715305d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#gab6d4e39ac483ebaeb108f2954715305d">libusb_get_device_address</a> (<a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *dev)</td></tr>
<tr class="memdesc:gab6d4e39ac483ebaeb108f2954715305d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address of the device on the bus it is connected to.  <a href="#gab6d4e39ac483ebaeb108f2954715305d">More...</a><br /></td></tr>
<tr class="separator:gab6d4e39ac483ebaeb108f2954715305d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58c4e448ecd5cd4782f2b896ec40b22b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#ga58c4e448ecd5cd4782f2b896ec40b22b">libusb_get_device_speed</a> (<a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *dev)</td></tr>
<tr class="memdesc:ga58c4e448ecd5cd4782f2b896ec40b22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the negotiated connection speed for a device.  <a href="#ga58c4e448ecd5cd4782f2b896ec40b22b">More...</a><br /></td></tr>
<tr class="separator:ga58c4e448ecd5cd4782f2b896ec40b22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac81968047e262409e78f3fe24321b604"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#gac81968047e262409e78f3fe24321b604">libusb_get_max_packet_size</a> (<a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *dev, unsigned char endpoint)</td></tr>
<tr class="memdesc:gac81968047e262409e78f3fe24321b604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to retrieve the wMaxPacketSize value for a particular endpoint in the active device configuration.  <a href="#gac81968047e262409e78f3fe24321b604">More...</a><br /></td></tr>
<tr class="separator:gac81968047e262409e78f3fe24321b604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec10b71c7209760db55ee0f8768bb4f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#gaec10b71c7209760db55ee0f8768bb4f0">libusb_get_max_iso_packet_size</a> (<a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *dev, unsigned char endpoint)</td></tr>
<tr class="memdesc:gaec10b71c7209760db55ee0f8768bb4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the maximum packet size which a specific endpoint is capable is sending or receiving in the duration of 1 microframe.  <a href="#gaec10b71c7209760db55ee0f8768bb4f0">More...</a><br /></td></tr>
<tr class="separator:gaec10b71c7209760db55ee0f8768bb4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabaa4193adcabba1789cc1165ac41a03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#gaabaa4193adcabba1789cc1165ac41a03">libusb_ref_device</a> (<a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *dev)</td></tr>
<tr class="memdesc:gaabaa4193adcabba1789cc1165ac41a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the reference count of a device.  <a href="#gaabaa4193adcabba1789cc1165ac41a03">More...</a><br /></td></tr>
<tr class="separator:gaabaa4193adcabba1789cc1165ac41a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cc62e6a191b7a9f213e62b81ec30f4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#ga3cc62e6a191b7a9f213e62b81ec30f4d">libusb_unref_device</a> (<a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *dev)</td></tr>
<tr class="memdesc:ga3cc62e6a191b7a9f213e62b81ec30f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the reference count of a device.  <a href="#ga3cc62e6a191b7a9f213e62b81ec30f4d">More...</a><br /></td></tr>
<tr class="separator:ga3cc62e6a191b7a9f213e62b81ec30f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f184a8be4488a767b2e0ae07e76d1b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open</a> (<a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *dev, <a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> **dev_handle)</td></tr>
<tr class="memdesc:ga3f184a8be4488a767b2e0ae07e76d1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a device and obtain a device handle.  <a href="#ga3f184a8be4488a767b2e0ae07e76d1b0">More...</a><br /></td></tr>
<tr class="separator:ga3f184a8be4488a767b2e0ae07e76d1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11ba48adb896b1492bbd3d0bf7e0f665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#ga11ba48adb896b1492bbd3d0bf7e0f665">libusb_open_device_with_vid_pid</a> (<a class="el" href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a> *ctx, uint16_t vendor_id, uint16_t product_id)</td></tr>
<tr class="memdesc:ga11ba48adb896b1492bbd3d0bf7e0f665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for finding a device with a particular <code>idVendor</code>/<code>idProduct</code> combination.  <a href="#ga11ba48adb896b1492bbd3d0bf7e0f665">More...</a><br /></td></tr>
<tr class="separator:ga11ba48adb896b1492bbd3d0bf7e0f665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga779bc4f1316bdb0ac383bddbd538620e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close</a> (<a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle)</td></tr>
<tr class="memdesc:ga779bc4f1316bdb0ac383bddbd538620e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a device handle.  <a href="#ga779bc4f1316bdb0ac383bddbd538620e">More...</a><br /></td></tr>
<tr class="separator:ga779bc4f1316bdb0ac383bddbd538620e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe70b8a797893d4d16985980acec956a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#gafe70b8a797893d4d16985980acec956a">libusb_get_device</a> (<a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle)</td></tr>
<tr class="memdesc:gafe70b8a797893d4d16985980acec956a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying device for a device handle.  <a href="#gafe70b8a797893d4d16985980acec956a">More...</a><br /></td></tr>
<tr class="separator:gafe70b8a797893d4d16985980acec956a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae921014b888b105471a31d54c77c1c4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#gae921014b888b105471a31d54c77c1c4d">libusb_get_configuration</a> (<a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, int *config)</td></tr>
<tr class="memdesc:gae921014b888b105471a31d54c77c1c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the bConfigurationValue of the currently active configuration.  <a href="#gae921014b888b105471a31d54c77c1c4d">More...</a><br /></td></tr>
<tr class="separator:gae921014b888b105471a31d54c77c1c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga785ddea63a2b9bcb879a614ca4867bed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration</a> (<a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, int configuration)</td></tr>
<tr class="memdesc:ga785ddea63a2b9bcb879a614ca4867bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the active configuration for a device.  <a href="#ga785ddea63a2b9bcb879a614ca4867bed">More...</a><br /></td></tr>
<tr class="separator:ga785ddea63a2b9bcb879a614ca4867bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee5076addf5de77c7962138397fd5b1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#gaee5076addf5de77c7962138397fd5b1a">libusb_claim_interface</a> (<a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, int interface_number)</td></tr>
<tr class="memdesc:gaee5076addf5de77c7962138397fd5b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Claim an interface on a given device handle.  <a href="#gaee5076addf5de77c7962138397fd5b1a">More...</a><br /></td></tr>
<tr class="separator:gaee5076addf5de77c7962138397fd5b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49b5cb0d894f6807cd1693ef29aecbfa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#ga49b5cb0d894f6807cd1693ef29aecbfa">libusb_release_interface</a> (<a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, int interface_number)</td></tr>
<tr class="memdesc:ga49b5cb0d894f6807cd1693ef29aecbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release an interface previously claimed with <a class="el" href="group__libusb__dev.html#gaee5076addf5de77c7962138397fd5b1a" title="Claim an interface on a given device handle. ">libusb_claim_interface()</a>.  <a href="#ga49b5cb0d894f6807cd1693ef29aecbfa">More...</a><br /></td></tr>
<tr class="separator:ga49b5cb0d894f6807cd1693ef29aecbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4858ad4f0f58fd1dc0afaead1fe6479a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#ga4858ad4f0f58fd1dc0afaead1fe6479a">libusb_set_interface_alt_setting</a> (<a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, int interface_number, int alternate_setting)</td></tr>
<tr class="memdesc:ga4858ad4f0f58fd1dc0afaead1fe6479a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate an alternate setting for an interface.  <a href="#ga4858ad4f0f58fd1dc0afaead1fe6479a">More...</a><br /></td></tr>
<tr class="separator:ga4858ad4f0f58fd1dc0afaead1fe6479a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab794bbc0b055d140f186f5a4d39c0891"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#gab794bbc0b055d140f186f5a4d39c0891">libusb_clear_halt</a> (<a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, unsigned char endpoint)</td></tr>
<tr class="memdesc:gab794bbc0b055d140f186f5a4d39c0891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the halt/stall condition for an endpoint.  <a href="#gab794bbc0b055d140f186f5a4d39c0891">More...</a><br /></td></tr>
<tr class="separator:gab794bbc0b055d140f186f5a4d39c0891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafee9c4638f1713ca5faa867948878111"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#gafee9c4638f1713ca5faa867948878111">libusb_reset_device</a> (<a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle)</td></tr>
<tr class="memdesc:gafee9c4638f1713ca5faa867948878111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a USB port reset to reinitialize a device.  <a href="#gafee9c4638f1713ca5faa867948878111">More...</a><br /></td></tr>
<tr class="separator:gafee9c4638f1713ca5faa867948878111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cabd4660a274f715eeb82de112e0779"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#ga1cabd4660a274f715eeb82de112e0779">libusb_kernel_driver_active</a> (<a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, int interface_number)</td></tr>
<tr class="memdesc:ga1cabd4660a274f715eeb82de112e0779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a kernel driver is active on an interface.  <a href="#ga1cabd4660a274f715eeb82de112e0779">More...</a><br /></td></tr>
<tr class="separator:ga1cabd4660a274f715eeb82de112e0779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e0cc1d666097e915748593effdc634a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#ga5e0cc1d666097e915748593effdc634a">libusb_detach_kernel_driver</a> (<a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, int interface_number)</td></tr>
<tr class="memdesc:ga5e0cc1d666097e915748593effdc634a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach a kernel driver from an interface.  <a href="#ga5e0cc1d666097e915748593effdc634a">More...</a><br /></td></tr>
<tr class="separator:ga5e0cc1d666097e915748593effdc634a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeba36e900db663c0b7cf1b164a20d02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#gadeba36e900db663c0b7cf1b164a20d02">libusb_attach_kernel_driver</a> (<a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, int interface_number)</td></tr>
<tr class="memdesc:gadeba36e900db663c0b7cf1b164a20d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-attach an interface's kernel driver, which was previously detached using <a class="el" href="group__libusb__dev.html#ga5e0cc1d666097e915748593effdc634a" title="Detach a kernel driver from an interface. ">libusb_detach_kernel_driver()</a>.  <a href="#gadeba36e900db663c0b7cf1b164a20d02">More...</a><br /></td></tr>
<tr class="separator:gadeba36e900db663c0b7cf1b164a20d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac35b26fef01271eba65c60b2b3ce1cbf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__dev.html#gac35b26fef01271eba65c60b2b3ce1cbf">libusb_set_auto_detach_kernel_driver</a> (<a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, int enable)</td></tr>
<tr class="memdesc:gac35b26fef01271eba65c60b2b3ce1cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable libusb's automatic kernel driver detachment.  <a href="#gac35b26fef01271eba65c60b2b3ce1cbf">More...</a><br /></td></tr>
<tr class="separator:gac35b26fef01271eba65c60b2b3ce1cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The functionality documented below is designed to help with the following operations: </p>
<ul>
<li>Enumerating the USB devices currently attached to the system</li>
<li>Choosing a device to operate from your software</li>
<li>Opening and closing the chosen device</li>
</ul>
<h1><a class="anchor" id="nutshell"></a>
In a nutshell...</h1>
<p>The description below really makes things sound more complicated than they actually are. The following sequence of function calls will be suitable for almost all scenarios and does not require you to have such a deep understanding of the resource management issues: </p><div class="fragment"><div class="line"><span class="comment">// discover devices</span></div><div class="line"><a class="code" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> **list;</div><div class="line"><a class="code" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *found = NULL;</div><div class="line">ssize_t cnt = <a class="code" href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97">libusb_get_device_list</a>(NULL, &amp;list);</div><div class="line">ssize_t i = 0;</div><div class="line"><span class="keywordtype">int</span> err = 0;</div><div class="line"><span class="keywordflow">if</span> (cnt &lt; 0)</div><div class="line">    error();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; cnt; i++) {</div><div class="line">    <a class="code" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *device = list[i];</div><div class="line">    <span class="keywordflow">if</span> (is_interesting(device)) {</div><div class="line">        found = device;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (found) {</div><div class="line">    <a class="code" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *handle;</div><div class="line"></div><div class="line">    err = <a class="code" href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open</a>(found, &amp;handle);</div><div class="line">    <span class="keywordflow">if</span> (err)</div><div class="line">        error();</div><div class="line">    <span class="comment">// etc</span></div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6">libusb_free_device_list</a>(list, 1);</div></div><!-- fragment --><p>The two important points:</p><ul>
<li>You asked <a class="el" href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6" title="Frees a list of devices previously discovered using libusb_get_device_list(). ">libusb_free_device_list()</a> to unreference the devices (2nd parameter)</li>
<li>You opened the device before freeing the list and unreferencing the devices</li>
</ul>
<p>If you ended up with a handle, you can now proceed to perform I/O on the device.</p>
<h1><a class="anchor" id="devshandles"></a>
Devices and device handles</h1>
<p>libusb has a concept of a USB device, represented by the <a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> opaque type. A device represents a USB device that is currently or was previously connected to the system. Using a reference to a device, you can determine certain information about the device (e.g. you can read the descriptor data).</p>
<p>The <a class="el" href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97" title="Returns a list of USB devices currently attached to the system. ">libusb_get_device_list()</a> function can be used to obtain a list of devices currently connected to the system. This is known as device discovery.</p>
<p>Just because you have a reference to a device does not mean it is necessarily usable. The device may have been unplugged, you may not have permission to operate such device, or another program or driver may be using the device.</p>
<p>When you've found a device that you'd like to operate, you must ask libusb to open the device using the <a class="el" href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0" title="Open a device and obtain a device handle. ">libusb_open()</a> function. Assuming success, libusb then returns you a <em>device handle</em> (a <a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> pointer). All "real" I/O operations then operate on the handle rather than the original device pointer.</p>
<h1><a class="anchor" id="devref"></a>
Device discovery and reference counting</h1>
<p>Device discovery (i.e. calling <a class="el" href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97" title="Returns a list of USB devices currently attached to the system. ">libusb_get_device_list()</a>) returns a freshly-allocated list of devices. The list itself must be freed when you are done with it. libusb also needs to know when it is OK to free the contents of the list - the devices themselves.</p>
<p>To handle these issues, libusb provides you with two separate items:</p><ul>
<li>A function to free the list itself</li>
<li>A reference counting system for the devices inside</li>
</ul>
<p>New devices presented by the <a class="el" href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97" title="Returns a list of USB devices currently attached to the system. ">libusb_get_device_list()</a> function all have a reference count of 1. You can increase and decrease reference count using <a class="el" href="group__libusb__dev.html#gaabaa4193adcabba1789cc1165ac41a03" title="Increment the reference count of a device. ">libusb_ref_device()</a> and <a class="el" href="group__libusb__dev.html#ga3cc62e6a191b7a9f213e62b81ec30f4d" title="Decrement the reference count of a device. ">libusb_unref_device()</a>. A device is destroyed when its reference count reaches 0.</p>
<p>With the above information in mind, the process of opening a device can be viewed as follows:</p><ol type="1">
<li>Discover devices using <a class="el" href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97" title="Returns a list of USB devices currently attached to the system. ">libusb_get_device_list()</a>.</li>
<li>Choose the device that you want to operate, and call <a class="el" href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0" title="Open a device and obtain a device handle. ">libusb_open()</a>.</li>
<li>Unref all devices in the discovered device list.</li>
<li>Free the discovered device list.</li>
</ol>
<p>The order is important - you must not unreference the device before attempting to open it, because unreferencing it may destroy the device.</p>
<p>For convenience, the <a class="el" href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6" title="Frees a list of devices previously discovered using libusb_get_device_list(). ">libusb_free_device_list()</a> function includes a parameter to optionally unreference all the devices in the list before freeing the list itself. This combines steps 3 and 4 above.</p>
<p>As an implementation detail, <a class="el" href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0" title="Open a device and obtain a device handle. ">libusb_open()</a> actually adds a reference to the device in question. This is because the device remains available through the handle via <a class="el" href="group__libusb__dev.html#gafe70b8a797893d4d16985980acec956a" title="Get the underlying device for a device handle. ">libusb_get_device()</a>. The reference is deleted during <a class="el" href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e" title="Close a device handle. ">libusb_close()</a>. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga77eedd00d01eb7569b880e861a971c2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> <a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure representing a USB device detected on the system. </p>
<p>This is an opaque type for which you are only ever provided with a pointer, usually originating from <a class="el" href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97" title="Returns a list of USB devices currently attached to the system. ">libusb_get_device_list()</a>.</p>
<p>Certain operations can be performed on a device, but in order to do any I/O you will have to first obtain a device handle using <a class="el" href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0" title="Open a device and obtain a device handle. ">libusb_open()</a>.</p>
<p>Devices are reference counted with <a class="el" href="group__libusb__dev.html#gaabaa4193adcabba1789cc1165ac41a03" title="Increment the reference count of a device. ">libusb_ref_device()</a> and <a class="el" href="group__libusb__dev.html#ga3cc62e6a191b7a9f213e62b81ec30f4d" title="Decrement the reference count of a device. ">libusb_unref_device()</a>, and are freed when the reference count reaches 0. New devices presented by <a class="el" href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97" title="Returns a list of USB devices currently attached to the system. ">libusb_get_device_list()</a> have a reference count of 1, and <a class="el" href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6" title="Frees a list of devices previously discovered using libusb_get_device_list(). ">libusb_free_device_list()</a> can optionally decrease the reference count on all devices in the list. <a class="el" href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0" title="Open a device and obtain a device handle. ">libusb_open()</a> adds another reference which is later destroyed by <a class="el" href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e" title="Close a device handle. ">libusb_close()</a>. </p>

</div>
</div>
<a class="anchor" id="ga7df95821d20d27b5597f1d783749d6a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> <a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure representing a handle on a USB device. </p>
<p>This is an opaque type for which you are only ever provided with a pointer, usually originating from <a class="el" href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0" title="Open a device and obtain a device handle. ">libusb_open()</a>.</p>
<p>A device handle is used to perform I/O and other operations. When finished with a device handle, you should call <a class="el" href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e" title="Close a device handle. ">libusb_close()</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga2959abf1184f87b2ce06fe90db6ce614"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__libusb__dev.html#ga2959abf1184f87b2ce06fe90db6ce614">libusb_speed</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Speed codes. </p>
<p>Indicates the speed at which the device is operating. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga2959abf1184f87b2ce06fe90db6ce614ace31df1e97e9a66146ac83dcab1e6cfb"></a>LIBUSB_SPEED_UNKNOWN&#160;</td><td class="fielddoc">
<p>The OS doesn't report or know the device speed. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2959abf1184f87b2ce06fe90db6ce614a6017f9ac2509cd523b51c1b72ad6991b"></a>LIBUSB_SPEED_LOW&#160;</td><td class="fielddoc">
<p>The device is operating at low speed (1.5MBit/s). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2959abf1184f87b2ce06fe90db6ce614a0011bead7a48b873808795d8495b4d9e"></a>LIBUSB_SPEED_FULL&#160;</td><td class="fielddoc">
<p>The device is operating at full speed (12MBit/s). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2959abf1184f87b2ce06fe90db6ce614a27bc0b9fe76f8ddf524f3d2ece0eefac"></a>LIBUSB_SPEED_HIGH&#160;</td><td class="fielddoc">
<p>The device is operating at high speed (480MBit/s). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2959abf1184f87b2ce06fe90db6ce614ab8c71e1409cd555ae05937b4db9946a2"></a>LIBUSB_SPEED_SUPER&#160;</td><td class="fielddoc">
<p>The device is operating at super speed (5000MBit/s). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2959abf1184f87b2ce06fe90db6ce614aa65f23e14e68162a142f26dac5fcfc4a"></a>LIBUSB_SPEED_SUPER_PLUS&#160;</td><td class="fielddoc">
<p>The device is operating at super speed plus (10000MBit/s). </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga1454797ecc0de4d084c1619c420014f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__libusb__dev.html#ga1454797ecc0de4d084c1619c420014f6">libusb_supported_speed</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported speeds (wSpeedSupported) bitfield. </p>
<p>Indicates what speeds the device supports. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga1454797ecc0de4d084c1619c420014f6aa7707c4cef77f4be8aceef859fad2087"></a>LIBUSB_LOW_SPEED_OPERATION&#160;</td><td class="fielddoc">
<p>Low speed operation supported (1.5MBit/s). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1454797ecc0de4d084c1619c420014f6adbebc659daf53947527259172f81b41a"></a>LIBUSB_FULL_SPEED_OPERATION&#160;</td><td class="fielddoc">
<p>Full speed operation supported (12MBit/s). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1454797ecc0de4d084c1619c420014f6a2db8b2bb845a23ad1083521ff5b6e9a8"></a>LIBUSB_HIGH_SPEED_OPERATION&#160;</td><td class="fielddoc">
<p>High speed operation supported (480MBit/s). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1454797ecc0de4d084c1619c420014f6accd7b9361912b76e40348dc30e6dc7f4"></a>LIBUSB_SUPER_SPEED_OPERATION&#160;</td><td class="fielddoc">
<p>Superspeed operation supported (5000MBit/s). </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gacb8cfa928bffdd0066a3dd2e6aba0558"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__libusb__dev.html#gacb8cfa928bffdd0066a3dd2e6aba0558">libusb_usb_2_0_extension_attributes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Masks for the bits of the <a class="el" href="structlibusb__usb__2__0__extension__descriptor.html#ab22e1857d38c9205aaecca52b2e20ae0">bmAttributes</a> field of the USB 2.0 Extension descriptor. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggacb8cfa928bffdd0066a3dd2e6aba0558a02f60b018f4bc01e8813da813779b792"></a>LIBUSB_BM_LPM_SUPPORT&#160;</td><td class="fielddoc">
<p>Supports Link Power Management (LPM) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaad5a5399176a35a64164dafad7fe4fcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__libusb__dev.html#gaad5a5399176a35a64164dafad7fe4fcd">libusb_ss_usb_device_capability_attributes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Masks for the bits of the <a class="el" href="structlibusb__ss__usb__device__capability__descriptor.html#ad387790c14d8d6eefe6aa1b4a55006bf">bmAttributes</a> field field of the SuperSpeed USB Device Capability descriptor. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaad5a5399176a35a64164dafad7fe4fcda5987a17b394338df71c1e04c5c75bc21"></a>LIBUSB_BM_LTM_SUPPORT&#160;</td><td class="fielddoc">
<p>Supports Latency Tolerance Messages (LTM) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga6ccabbf3b3728ae69608ba83bba4e64c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__libusb__dev.html#ga6ccabbf3b3728ae69608ba83bba4e64c">libusb_bos_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB capability types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga6ccabbf3b3728ae69608ba83bba4e64cac05dcfcd0a5c0dbaef90b1d09e4b5505"></a>LIBUSB_BT_WIRELESS_USB_DEVICE_CAPABILITY&#160;</td><td class="fielddoc">
<p>Wireless USB device capability. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6ccabbf3b3728ae69608ba83bba4e64ca243b090db95a0fdf7104fbf581724b86"></a>LIBUSB_BT_USB_2_0_EXTENSION&#160;</td><td class="fielddoc">
<p>USB 2.0 extensions. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6ccabbf3b3728ae69608ba83bba4e64ca2f1ab0d2d1e14d4942c079749b1b6c85"></a>LIBUSB_BT_SS_USB_DEVICE_CAPABILITY&#160;</td><td class="fielddoc">
<p>SuperSpeed USB device capability. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6ccabbf3b3728ae69608ba83bba4e64cac3c00e8861b4b596ea1f53c505809e5e"></a>LIBUSB_BT_CONTAINER_ID&#160;</td><td class="fielddoc">
<p>Container ID type. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac0fe4b65914c5ed036e6cbec61cb0b97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t libusb_get_device_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> ***&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of USB devices currently attached to the system. </p>
<p>This is your entry point into finding a USB device to operate.</p>
<p>You are expected to unreference all the devices when you are done with them, and then free the list with <a class="el" href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6" title="Frees a list of devices previously discovered using libusb_get_device_list(). ">libusb_free_device_list()</a>. Note that <a class="el" href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6" title="Frees a list of devices previously discovered using libusb_get_device_list(). ">libusb_free_device_list()</a> can unref all the devices for you. Be careful not to unreference a device you are about to open until after you have opened it.</p>
<p>This return value of this function indicates the number of devices in the resultant list. The list is actually one element larger, as it is NULL-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the context to operate on, or NULL for the default context </td></tr>
    <tr><td class="paramname">list</td><td>output location for a list of devices. Must be later freed with <a class="el" href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6" title="Frees a list of devices previously discovered using libusb_get_device_list(). ">libusb_free_device_list()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of devices in the outputted list, or any <a class="el" href="group__libusb__misc.html#gab2323aa0f04bc22038e7e1740b2f29ef">libusb_error</a> according to errors encountered by the backend. </dd></dl>

</div>
</div>
<a class="anchor" id="gad3b8561d064bb3e1b8851ddeed3cd7d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libusb_free_device_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> **&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>unref_devices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a list of devices previously discovered using <a class="el" href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97" title="Returns a list of USB devices currently attached to the system. ">libusb_get_device_list()</a>. </p>
<p>If the unref_devices parameter is set, the reference count of each device in the list is decremented by 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list to free </td></tr>
    <tr><td class="paramname">unref_devices</td><td>whether to unref the devices in the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf2718609d50c8ded2704e4051b3d2925"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t libusb_get_bus_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of the bus that a device is connected to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bus number </dd></dl>

</div>
</div>
<a class="anchor" id="ga14879a0ea7daccdcddb68852d86c00c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t libusb_get_port_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of the port that a device is connected to. </p>
<p>Unless the OS does something funky, or you are hot-plugging USB extension cards, the port number returned by this call is usually guaranteed to be uniquely tied to a physical port, meaning that different devices plugged on the same physical port should return the same port number.</p>
<p>But outside of this, there is no guarantee that the port number returned by this call will remain the same, or even match the order in which ports have been numbered by the HUB/HCD manufacturer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the port number (0 if not available) </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4b7b2b50a9ce2aa396b0af2b979544d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_get_port_numbers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>port_numbers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port_numbers_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of all port numbers from root for the specified device. </p>
<p>Since version 1.0.16, <a class="el" href="group__libusb__misc.html#gaabe4bc36a83358685d36a6c853cbb4de">LIBUSB_API_VERSION</a> &gt;= 0x01000102 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
    <tr><td class="paramname">port_numbers</td><td>the array that should contain the port numbers </td></tr>
    <tr><td class="paramname">port_numbers_len</td><td>the maximum length of the array. As per the USB 3.0 specs, the current maximum limit for the depth is 7. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of elements filled </dd>
<dd>
LIBUSB_ERROR_OVERFLOW if the array is too small </dd></dl>

</div>
</div>
<a class="anchor" id="ga97bb4dfff6bbb897ed9dfd6fa1a1deed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>* libusb_get_parent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the the parent from the specified device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the device parent or NULL if not available You should issue a <a class="el" href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97">libusb_get_device_list()</a> before calling this function and make sure that you only access the parent before issuing <a class="el" href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6">libusb_free_device_list()</a>. The reason is that libusb currently does not maintain a permanent list of device instances, and therefore can only guarantee that parents are fully instantiated within a <a class="el" href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97" title="Returns a list of USB devices currently attached to the system. ">libusb_get_device_list()</a> - <a class="el" href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6" title="Frees a list of devices previously discovered using libusb_get_device_list(). ">libusb_free_device_list()</a> block. </dd></dl>

</div>
</div>
<a class="anchor" id="gab6d4e39ac483ebaeb108f2954715305d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t libusb_get_device_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the address of the device on the bus it is connected to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the device address </dd></dl>

</div>
</div>
<a class="anchor" id="ga58c4e448ecd5cd4782f2b896ec40b22b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_get_device_speed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the negotiated connection speed for a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="group__libusb__dev.html#ga2959abf1184f87b2ce06fe90db6ce614">libusb_speed</a> code, where LIBUSB_SPEED_UNKNOWN means that the OS doesn't know or doesn't support returning the negotiated speed. </dd></dl>

</div>
</div>
<a class="anchor" id="gac81968047e262409e78f3fe24321b604"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_get_max_packet_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to retrieve the wMaxPacketSize value for a particular endpoint in the active device configuration. </p>
<p>This function was originally intended to be of assistance when setting up isochronous transfers, but a design mistake resulted in this function instead. It simply returns the wMaxPacketSize value without considering its contents. If you're dealing with isochronous transfers, you probably want <a class="el" href="group__libusb__dev.html#gaec10b71c7209760db55ee0f8768bb4f0" title="Calculate the maximum packet size which a specific endpoint is capable is sending or receiving in the...">libusb_get_max_iso_packet_size()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
    <tr><td class="paramname">endpoint</td><td>address of the endpoint in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the wMaxPacketSize value </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if the endpoint does not exist </dd>
<dd>
LIBUSB_ERROR_OTHER on other failure </dd></dl>

</div>
</div>
<a class="anchor" id="gaec10b71c7209760db55ee0f8768bb4f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_get_max_iso_packet_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the maximum packet size which a specific endpoint is capable is sending or receiving in the duration of 1 microframe. </p>
<p>Only the active configuration is examined. The calculation is based on the wMaxPacketSize field in the endpoint descriptor as described in section 9.6.6 in the USB 2.0 specifications.</p>
<p>If acting on an isochronous or interrupt endpoint, this function will multiply the value found in bits 0:10 by the number of transactions per microframe (determined by bits 11:12). Otherwise, this function just returns the numeric value found in bits 0:10.</p>
<p>This function is useful for setting up isochronous transfers, for example you might pass the return value from this function to <a class="el" href="group__libusb__asyncio.html#gacbdecd6f50093f0c1d0e72ee35ace274" title="Convenience function to set the length of all packets in an isochronous transfer, based on the num_is...">libusb_set_iso_packet_lengths()</a> in order to set the length field of every isochronous packet in a transfer.</p>
<p>Since v1.0.3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
    <tr><td class="paramname">endpoint</td><td>address of the endpoint in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum packet size which can be sent/received on this endpoint </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if the endpoint does not exist </dd>
<dd>
LIBUSB_ERROR_OTHER on other failure </dd></dl>

</div>
</div>
<a class="anchor" id="gaabaa4193adcabba1789cc1165ac41a03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>* libusb_ref_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment the reference count of a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>the device to reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the same device </dd></dl>

</div>
</div>
<a class="anchor" id="ga3cc62e6a191b7a9f213e62b81ec30f4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libusb_unref_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrement the reference count of a device. </p>
<p>If the decrement operation causes the reference count to reach zero, the device shall be destroyed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>the device to unreference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3f184a8be4488a767b2e0ae07e76d1b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> **&#160;</td>
          <td class="paramname"><em>dev_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a device and obtain a device handle. </p>
<p>A handle allows you to perform I/O on the device in question.</p>
<p>Internally, this function adds a reference to the device and makes it available to you through <a class="el" href="group__libusb__dev.html#gafe70b8a797893d4d16985980acec956a" title="Get the underlying device for a device handle. ">libusb_get_device()</a>. This reference is removed during <a class="el" href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e" title="Close a device handle. ">libusb_close()</a>.</p>
<p>This is a non-blocking function; no requests are sent over the bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>the device to open </td></tr>
    <tr><td class="paramname">dev_handle</td><td>output location for the returned device handle pointer. Only populated when the return code is 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NO_MEM on memory allocation failure </dd>
<dd>
LIBUSB_ERROR_ACCESS if the user has insufficient permissions </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga11ba48adb896b1492bbd3d0bf7e0f665"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>* libusb_open_device_with_vid_pid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>vendor_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>product_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for finding a device with a particular <code>idVendor</code>/<code>idProduct</code> combination. </p>
<p>This function is intended for those scenarios where you are using libusb to knock up a quick test application - it allows you to avoid calling <a class="el" href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97" title="Returns a list of USB devices currently attached to the system. ">libusb_get_device_list()</a> and worrying about traversing/freeing the list.</p>
<p>This function has limitations and is hence not intended for use in real applications: if multiple devices have the same IDs it will only give you the first one, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the context to operate on, or NULL for the default context </td></tr>
    <tr><td class="paramname">vendor_id</td><td>the idVendor value to search for </td></tr>
    <tr><td class="paramname">product_id</td><td>the idProduct value to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a device handle for the first found device, or NULL on error or if the device could not be found. </dd></dl>

</div>
</div>
<a class="anchor" id="ga779bc4f1316bdb0ac383bddbd538620e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libusb_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a device handle. </p>
<p>Should be called on all open handles before your application exits.</p>
<p>Internally, this function destroys the reference that was added by <a class="el" href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0" title="Open a device and obtain a device handle. ">libusb_open()</a> on the given device.</p>
<p>This is a non-blocking function; no requests are sent over the bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>the device handle to close </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafe70b8a797893d4d16985980acec956a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>* libusb_get_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the underlying device for a device handle. </p>
<p>This function does not modify the reference count of the returned device, so do not feel compelled to unreference it when you are done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the underlying device </dd></dl>

</div>
</div>
<a class="anchor" id="gae921014b888b105471a31d54c77c1c4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_get_configuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the bConfigurationValue of the currently active configuration. </p>
<p>You could formulate your own control request to obtain this information, but this function has the advantage that it may be able to retrieve the information from operating system caches (no I/O involved).</p>
<p>If the OS does not cache this information, then this function will block while a control transfer is submitted to retrieve the information.</p>
<p>This function will return a value of 0 in the <code>config</code> output parameter if the device is in unconfigured state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">config</td><td>output location for the bConfigurationValue of the active configuration (only valid for return code 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga785ddea63a2b9bcb879a614ca4867bed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_set_configuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>configuration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the active configuration for a device. </p>
<p>The operating system may or may not have already set an active configuration on the device. It is up to your application to ensure the correct configuration is selected before you attempt to claim interfaces and perform other operations.</p>
<p>If you call this function on a device already configured with the selected configuration, then this function will act as a lightweight device reset: it will issue a SET_CONFIGURATION request using the current configuration, causing most USB-related device state to be reset (altsetting reset to zero, endpoint halts cleared, toggles reset).</p>
<p>You cannot change/reset configuration if your application has claimed interfaces. It is advised to set the desired configuration before claiming interfaces.</p>
<p>Alternatively you can call <a class="el" href="group__libusb__dev.html#ga49b5cb0d894f6807cd1693ef29aecbfa" title="Release an interface previously claimed with libusb_claim_interface(). ">libusb_release_interface()</a> first. Note if you do things this way you must ensure that auto_detach_kernel_driver for <code>dev</code> is 0, otherwise the kernel driver will be re-attached when you release the interface(s).</p>
<p>You cannot change/reset configuration if other applications or drivers have claimed interfaces.</p>
<p>A configuration value of -1 will put the device in unconfigured state. The USB specifications state that a configuration value of 0 does this, however buggy devices exist which actually have a configuration 0.</p>
<p>You should always use this function rather than formulating your own SET_CONFIGURATION control request. This is because the underlying operating system needs to know when such changes happen.</p>
<p>This is a blocking function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">configuration</td><td>the bConfigurationValue of the configuration you wish to activate, or -1 if you wish to put the device in an unconfigured state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if the requested configuration does not exist </dd>
<dd>
LIBUSB_ERROR_BUSY if interfaces are currently claimed </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libusb__dev.html#gac35b26fef01271eba65c60b2b3ce1cbf" title="Enable/disable libusb&#39;s automatic kernel driver detachment. ">libusb_set_auto_detach_kernel_driver()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaee5076addf5de77c7962138397fd5b1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_claim_interface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interface_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Claim an interface on a given device handle. </p>
<p>You must claim the interface you wish to use before you can perform I/O on any of its endpoints.</p>
<p>It is legal to attempt to claim an already-claimed interface, in which case libusb just returns 0 without doing anything.</p>
<p>If auto_detach_kernel_driver is set to 1 for <code>dev</code>, the kernel driver will be detached if necessary, on failure the detach error is returned.</p>
<p>Claiming of interfaces is a purely logical operation; it does not cause any requests to be sent over the bus. Interface claiming is used to instruct the underlying operating system that your application wishes to take ownership of the interface.</p>
<p>This is a non-blocking function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">interface_number</td><td>the <code>bInterfaceNumber</code> of the interface you wish to claim </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if the requested interface does not exist </dd>
<dd>
LIBUSB_ERROR_BUSY if another program or driver has claimed the interface </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
a LIBUSB_ERROR code on other failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libusb__dev.html#gac35b26fef01271eba65c60b2b3ce1cbf" title="Enable/disable libusb&#39;s automatic kernel driver detachment. ">libusb_set_auto_detach_kernel_driver()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga49b5cb0d894f6807cd1693ef29aecbfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_release_interface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interface_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release an interface previously claimed with <a class="el" href="group__libusb__dev.html#gaee5076addf5de77c7962138397fd5b1a" title="Claim an interface on a given device handle. ">libusb_claim_interface()</a>. </p>
<p>You should release all claimed interfaces before closing a device handle.</p>
<p>This is a blocking function. A SET_INTERFACE control request will be sent to the device, resetting interface state to the first alternate setting.</p>
<p>If auto_detach_kernel_driver is set to 1 for <code>dev</code>, the kernel driver will be re-attached after releasing the interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">interface_number</td><td>the <code>bInterfaceNumber</code> of the previously-claimed interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if the interface was not claimed </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libusb__dev.html#gac35b26fef01271eba65c60b2b3ce1cbf" title="Enable/disable libusb&#39;s automatic kernel driver detachment. ">libusb_set_auto_detach_kernel_driver()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4858ad4f0f58fd1dc0afaead1fe6479a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_set_interface_alt_setting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interface_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alternate_setting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate an alternate setting for an interface. </p>
<p>The interface must have been previously claimed with <a class="el" href="group__libusb__dev.html#gaee5076addf5de77c7962138397fd5b1a" title="Claim an interface on a given device handle. ">libusb_claim_interface()</a>.</p>
<p>You should always use this function rather than formulating your own SET_INTERFACE control request. This is because the underlying operating system needs to know when such changes happen.</p>
<p>This is a blocking function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">interface_number</td><td>the <code>bInterfaceNumber</code> of the previously-claimed interface </td></tr>
    <tr><td class="paramname">alternate_setting</td><td>the <code>bAlternateSetting</code> of the alternate setting to activate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if the interface was not claimed, or the requested alternate setting does not exist </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>

</div>
</div>
<a class="anchor" id="gab794bbc0b055d140f186f5a4d39c0891"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_clear_halt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the halt/stall condition for an endpoint. </p>
<p>Endpoints with halt status are unable to receive or transmit data until the halt condition is stalled.</p>
<p>You should cancel all pending transfers before attempting to clear the halt condition.</p>
<p>This is a blocking function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">endpoint</td><td>the endpoint to clear halt status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if the endpoint does not exist </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>

</div>
</div>
<a class="anchor" id="gafee9c4638f1713ca5faa867948878111"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_reset_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a USB port reset to reinitialize a device. </p>
<p>The system will attempt to restore the previous configuration and alternate settings after the reset has completed.</p>
<p>If the reset fails, the descriptors change, or the previous state cannot be restored, the device will appear to be disconnected and reconnected. This means that the device handle is no longer valid (you should close it) and rediscover the device. A return code of LIBUSB_ERROR_NOT_FOUND indicates when this is the case.</p>
<p>This is a blocking function which usually incurs a noticeable delay.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a handle of the device to reset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if re-enumeration is required, or if the device has been disconnected </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga1cabd4660a274f715eeb82de112e0779"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_kernel_driver_active </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interface_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a kernel driver is active on an interface. </p>
<p>If a kernel driver is active, you cannot claim the interface, and libusb will be unable to perform I/O.</p>
<p>This functionality is not available on Windows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">interface_number</td><td>the interface to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if no kernel driver is active </dd>
<dd>
1 if a kernel driver is active </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
LIBUSB_ERROR_NOT_SUPPORTED on platforms where the functionality is not available </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libusb__dev.html#ga5e0cc1d666097e915748593effdc634a" title="Detach a kernel driver from an interface. ">libusb_detach_kernel_driver()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e0cc1d666097e915748593effdc634a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_detach_kernel_driver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interface_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach a kernel driver from an interface. </p>
<p>If successful, you will then be able to claim the interface and perform I/O.</p>
<p>This functionality is not available on Darwin or Windows.</p>
<p>Note that libusb itself also talks to the device through a special kernel driver, if this driver is already attached to the device, this call will not detach it and return LIBUSB_ERROR_NOT_FOUND.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">interface_number</td><td>the interface to detach the driver from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if no kernel driver was active </dd>
<dd>
LIBUSB_ERROR_INVALID_PARAM if the interface does not exist </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
LIBUSB_ERROR_NOT_SUPPORTED on platforms where the functionality is not available </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libusb__dev.html#ga1cabd4660a274f715eeb82de112e0779" title="Determine if a kernel driver is active on an interface. ">libusb_kernel_driver_active()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadeba36e900db663c0b7cf1b164a20d02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_attach_kernel_driver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interface_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-attach an interface's kernel driver, which was previously detached using <a class="el" href="group__libusb__dev.html#ga5e0cc1d666097e915748593effdc634a" title="Detach a kernel driver from an interface. ">libusb_detach_kernel_driver()</a>. </p>
<p>This call is only effective on Linux and returns LIBUSB_ERROR_NOT_SUPPORTED on all other platforms.</p>
<p>This functionality is not available on Darwin or Windows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">interface_number</td><td>the interface to attach the driver from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if no kernel driver was active </dd>
<dd>
LIBUSB_ERROR_INVALID_PARAM if the interface does not exist </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
LIBUSB_ERROR_NOT_SUPPORTED on platforms where the functionality is not available </dd>
<dd>
LIBUSB_ERROR_BUSY if the driver cannot be attached because the interface is claimed by a program or driver </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libusb__dev.html#ga1cabd4660a274f715eeb82de112e0779" title="Determine if a kernel driver is active on an interface. ">libusb_kernel_driver_active()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac35b26fef01271eba65c60b2b3ce1cbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_set_auto_detach_kernel_driver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable libusb's automatic kernel driver detachment. </p>
<p>When this is enabled libusb will automatically detach the kernel driver on an interface when claiming the interface, and attach it when releasing the interface.</p>
<p>Automatic kernel driver detachment is disabled on newly opened device handles by default.</p>
<p>On platforms which do not have LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER this function will return LIBUSB_ERROR_NOT_SUPPORTED, and libusb will continue as if this function was never called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">enable</td><td>whether to enable or disable auto kernel driver detachment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LIBUSB_SUCCESS on success </dd>
<dd>
LIBUSB_ERROR_NOT_SUPPORTED on platforms where the functionality is not available </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libusb__dev.html#gaee5076addf5de77c7962138397fd5b1a" title="Claim an interface on a given device handle. ">libusb_claim_interface()</a> </dd>
<dd>
<a class="el" href="group__libusb__dev.html#ga49b5cb0d894f6807cd1693ef29aecbfa" title="Release an interface previously claimed with libusb_claim_interface(). ">libusb_release_interface()</a> </dd>
<dd>
<a class="el" href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed" title="Set the active configuration for a device. ">libusb_set_configuration()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 24 2018 18:50:59 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
