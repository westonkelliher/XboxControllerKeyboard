<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Asynchronous device I/O</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="libusb.png"/></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">A cross-platform user library to access USB devices</div>
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Asynchronous device I/O</div>  </div>
</div><!--header-->
<div class="contents">

<p>This page details libusb's asynchronous (non-blocking) API for USB device I/O.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibusb__control__setup.html">libusb_control_setup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup packet for control transfers.  <a href="structlibusb__control__setup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibusb__iso__packet__descriptor.html">libusb_iso_packet_descriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Isochronous packet descriptor.  <a href="structlibusb__iso__packet__descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibusb__transfer.html">libusb_transfer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic USB transfer structure.  <a href="structlibusb__transfer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac74874519794cd7aa40c0814702b0c88"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a>) (struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *transfer)</td></tr>
<tr class="memdesc:gac74874519794cd7aa40c0814702b0c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous transfer callback function type.  <a href="#gac74874519794cd7aa40c0814702b0c88">More...</a><br /></td></tr>
<tr class="separator:gac74874519794cd7aa40c0814702b0c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9fcb2aa23d342060ebda1d0cf7478856"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#ga9fcb2aa23d342060ebda1d0cf7478856">libusb_transfer_status</a> { <br />
&#160;&#160;<a class="el" href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856a4595f6532aab12352a58a0fd4ce48363">LIBUSB_TRANSFER_COMPLETED</a>, 
<a class="el" href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856aa8852ed719d03c2a3cc6f0312d919398">LIBUSB_TRANSFER_ERROR</a>, 
<a class="el" href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856ac2b7626d7b51cb980f83933b6ada1ddf">LIBUSB_TRANSFER_TIMED_OUT</a>, 
<a class="el" href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856a8af1f19e46cccafdcf3feadce47e880b">LIBUSB_TRANSFER_CANCELLED</a>, 
<br />
&#160;&#160;<a class="el" href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856a23cdfd929f5fe82cca9654f8075eeebb">LIBUSB_TRANSFER_STALL</a>, 
<a class="el" href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856ab7dcb24f313ace407e0c070d6b2c5f13">LIBUSB_TRANSFER_NO_DEVICE</a>, 
<a class="el" href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856ab1b9cbcb1de27a8fbeceb3427fb2fb14">LIBUSB_TRANSFER_OVERFLOW</a>
<br />
 }<tr class="memdesc:ga9fcb2aa23d342060ebda1d0cf7478856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer status codes.  <a href="group__libusb__asyncio.html#ga9fcb2aa23d342060ebda1d0cf7478856">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga9fcb2aa23d342060ebda1d0cf7478856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fb47dd0f7c209b60a3609ff0c03d56d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#ga1fb47dd0f7c209b60a3609ff0c03d56d">libusb_transfer_flags</a> { <a class="el" href="group__libusb__asyncio.html#gga1fb47dd0f7c209b60a3609ff0c03d56dae4c0697c266819c51c1734b3456e7276">LIBUSB_TRANSFER_SHORT_NOT_OK</a> = 1&lt;&lt;0, 
<a class="el" href="group__libusb__asyncio.html#gga1fb47dd0f7c209b60a3609ff0c03d56dae993a26f495ac9949118e23eafa19e86">LIBUSB_TRANSFER_FREE_BUFFER</a> = 1&lt;&lt;1, 
<a class="el" href="group__libusb__asyncio.html#gga1fb47dd0f7c209b60a3609ff0c03d56dacf3f064997b283a14097c9f4d6f8ccc1">LIBUSB_TRANSFER_FREE_TRANSFER</a> = 1&lt;&lt;2, 
<a class="el" href="group__libusb__asyncio.html#gga1fb47dd0f7c209b60a3609ff0c03d56da26b66334b6ec0537c49841ca623d901f">LIBUSB_TRANSFER_ADD_ZERO_PACKET</a> = 1 &lt;&lt; 3
 }<tr class="memdesc:ga1fb47dd0f7c209b60a3609ff0c03d56d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structlibusb__transfer.html#ae26c063df30c2e29835212aad98c6e06" title="A bitwise OR combination of libusb_transfer_flags. ">libusb_transfer.flags</a> values  <a href="group__libusb__asyncio.html#ga1fb47dd0f7c209b60a3609ff0c03d56d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga1fb47dd0f7c209b60a3609ff0c03d56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad7e786c1bedd4a668887564465101981"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#gad7e786c1bedd4a668887564465101981">libusb_alloc_streams</a> (<a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, uint32_t num_streams, unsigned char *endpoints, int num_endpoints)</td></tr>
<tr class="memdesc:gad7e786c1bedd4a668887564465101981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate up to num_streams usb bulk streams on the specified endpoints.  <a href="#gad7e786c1bedd4a668887564465101981">More...</a><br /></td></tr>
<tr class="separator:gad7e786c1bedd4a668887564465101981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab068de0fd203ccef5c620a8143526acb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#gab068de0fd203ccef5c620a8143526acb">libusb_free_streams</a> (<a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, unsigned char *endpoints, int num_endpoints)</td></tr>
<tr class="memdesc:gab068de0fd203ccef5c620a8143526acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free usb bulk streams allocated with <a class="el" href="group__libusb__asyncio.html#gad7e786c1bedd4a668887564465101981" title="Allocate up to num_streams usb bulk streams on the specified endpoints. ">libusb_alloc_streams()</a>.  <a href="#gab068de0fd203ccef5c620a8143526acb">More...</a><br /></td></tr>
<tr class="separator:gab068de0fd203ccef5c620a8143526acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47c492e750197f1a28874c7a0dee40e3"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#ga47c492e750197f1a28874c7a0dee40e3">libusb_dev_mem_alloc</a> (<a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, size_t length)</td></tr>
<tr class="memdesc:ga47c492e750197f1a28874c7a0dee40e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to allocate a block of persistent DMA memory suitable for transfers against the given device.  <a href="#ga47c492e750197f1a28874c7a0dee40e3">More...</a><br /></td></tr>
<tr class="separator:ga47c492e750197f1a28874c7a0dee40e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7575ff325f0159a5b74b7c0ee64eb62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#gad7575ff325f0159a5b74b7c0ee64eb62">libusb_dev_mem_free</a> (<a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, unsigned char *buffer, size_t length)</td></tr>
<tr class="memdesc:gad7575ff325f0159a5b74b7c0ee64eb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free device memory allocated with <a class="el" href="group__libusb__asyncio.html#ga47c492e750197f1a28874c7a0dee40e3" title="Attempts to allocate a block of persistent DMA memory suitable for transfers against the given device...">libusb_dev_mem_alloc()</a>.  <a href="#gad7575ff325f0159a5b74b7c0ee64eb62">More...</a><br /></td></tr>
<tr class="separator:gad7575ff325f0159a5b74b7c0ee64eb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13cc69ea40c702181c430c950121c000"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#ga13cc69ea40c702181c430c950121c000">libusb_alloc_transfer</a> (int iso_packets)</td></tr>
<tr class="memdesc:ga13cc69ea40c702181c430c950121c000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a libusb transfer with a specified number of isochronous packet descriptors.  <a href="#ga13cc69ea40c702181c430c950121c000">More...</a><br /></td></tr>
<tr class="separator:ga13cc69ea40c702181c430c950121c000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ab8b2cff4de9091298a06b2f4b86cd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#ga6ab8b2cff4de9091298a06b2f4b86cd6">libusb_free_transfer</a> (struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *transfer)</td></tr>
<tr class="memdesc:ga6ab8b2cff4de9091298a06b2f4b86cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a transfer structure.  <a href="#ga6ab8b2cff4de9091298a06b2f4b86cd6">More...</a><br /></td></tr>
<tr class="separator:ga6ab8b2cff4de9091298a06b2f4b86cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb0932601f2c7dad2fee4b27962848ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#gabb0932601f2c7dad2fee4b27962848ce">libusb_submit_transfer</a> (struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *transfer)</td></tr>
<tr class="memdesc:gabb0932601f2c7dad2fee4b27962848ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a transfer.  <a href="#gabb0932601f2c7dad2fee4b27962848ce">More...</a><br /></td></tr>
<tr class="separator:gabb0932601f2c7dad2fee4b27962848ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga685eb7731f9a0593f75beb99727bbe54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#ga685eb7731f9a0593f75beb99727bbe54">libusb_cancel_transfer</a> (struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *transfer)</td></tr>
<tr class="memdesc:ga685eb7731f9a0593f75beb99727bbe54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously cancel a previously submitted transfer.  <a href="#ga685eb7731f9a0593f75beb99727bbe54">More...</a><br /></td></tr>
<tr class="separator:ga685eb7731f9a0593f75beb99727bbe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeae2db23b9de811af317483afdeb230f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#gaeae2db23b9de811af317483afdeb230f">libusb_transfer_set_stream_id</a> (struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *transfer, uint32_t stream_id)</td></tr>
<tr class="memdesc:gaeae2db23b9de811af317483afdeb230f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a transfers bulk stream id.  <a href="#gaeae2db23b9de811af317483afdeb230f">More...</a><br /></td></tr>
<tr class="separator:gaeae2db23b9de811af317483afdeb230f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631653487273f3306925131cdc0a3ffc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#ga631653487273f3306925131cdc0a3ffc">libusb_transfer_get_stream_id</a> (struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *transfer)</td></tr>
<tr class="memdesc:ga631653487273f3306925131cdc0a3ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a transfers bulk stream id.  <a href="#ga631653487273f3306925131cdc0a3ffc">More...</a><br /></td></tr>
<tr class="separator:ga631653487273f3306925131cdc0a3ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf9c633586dde54ce62a3d66a4d7554c"><td class="memItemLeft" align="right" valign="top">static unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#gadf9c633586dde54ce62a3d66a4d7554c">libusb_control_transfer_get_data</a> (struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *transfer)</td></tr>
<tr class="memdesc:gadf9c633586dde54ce62a3d66a4d7554c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data section of a control transfer.  <a href="#gadf9c633586dde54ce62a3d66a4d7554c">More...</a><br /></td></tr>
<tr class="separator:gadf9c633586dde54ce62a3d66a4d7554c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ab02f15e11b5b03b1174fbd7c3bc061"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structlibusb__control__setup.html">libusb_control_setup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#ga6ab02f15e11b5b03b1174fbd7c3bc061">libusb_control_transfer_get_setup</a> (struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *transfer)</td></tr>
<tr class="memdesc:ga6ab02f15e11b5b03b1174fbd7c3bc061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the control setup packet of a control transfer.  <a href="#ga6ab02f15e11b5b03b1174fbd7c3bc061">More...</a><br /></td></tr>
<tr class="separator:ga6ab02f15e11b5b03b1174fbd7c3bc061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5447311149ec2bd954b5f1a640a8e231"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#ga5447311149ec2bd954b5f1a640a8e231">libusb_fill_control_setup</a> (unsigned char *buffer, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, uint16_t wLength)</td></tr>
<tr class="memdesc:ga5447311149ec2bd954b5f1a640a8e231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to populate the setup packet (first 8 bytes of the data buffer) for a control transfer.  <a href="#ga5447311149ec2bd954b5f1a640a8e231">More...</a><br /></td></tr>
<tr class="separator:ga5447311149ec2bd954b5f1a640a8e231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a8513ed87229fe2c9771ef0bf17206e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#ga3a8513ed87229fe2c9771ef0bf17206e">libusb_fill_control_transfer</a> (struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *transfer, <a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, unsigned char *buffer, <a class="el" href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a> callback, void *user_data, unsigned int timeout)</td></tr>
<tr class="memdesc:ga3a8513ed87229fe2c9771ef0bf17206e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to populate the required <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> fields for a control transfer.  <a href="#ga3a8513ed87229fe2c9771ef0bf17206e">More...</a><br /></td></tr>
<tr class="separator:ga3a8513ed87229fe2c9771ef0bf17206e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ddb1a5c6c7fefc979a44d7300b95d7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#gad4ddb1a5c6c7fefc979a44d7300b95d7">libusb_fill_bulk_transfer</a> (struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *transfer, <a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, unsigned char endpoint, unsigned char *buffer, int length, <a class="el" href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a> callback, void *user_data, unsigned int timeout)</td></tr>
<tr class="memdesc:gad4ddb1a5c6c7fefc979a44d7300b95d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to populate the required <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> fields for a bulk transfer.  <a href="#gad4ddb1a5c6c7fefc979a44d7300b95d7">More...</a><br /></td></tr>
<tr class="separator:gad4ddb1a5c6c7fefc979a44d7300b95d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e84d8fb9218d3c67e6a4fd4ade5b10"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#gac2e84d8fb9218d3c67e6a4fd4ade5b10">libusb_fill_bulk_stream_transfer</a> (struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *transfer, <a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, unsigned char endpoint, uint32_t stream_id, unsigned char *buffer, int length, <a class="el" href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a> callback, void *user_data, unsigned int timeout)</td></tr>
<tr class="memdesc:gac2e84d8fb9218d3c67e6a4fd4ade5b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to populate the required <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> fields for a bulk transfer using bulk streams.  <a href="#gac2e84d8fb9218d3c67e6a4fd4ade5b10">More...</a><br /></td></tr>
<tr class="separator:gac2e84d8fb9218d3c67e6a4fd4ade5b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90f53cea1124a7566df1aa1202b77510"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#ga90f53cea1124a7566df1aa1202b77510">libusb_fill_interrupt_transfer</a> (struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *transfer, <a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, unsigned char endpoint, unsigned char *buffer, int length, <a class="el" href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a> callback, void *user_data, unsigned int timeout)</td></tr>
<tr class="memdesc:ga90f53cea1124a7566df1aa1202b77510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to populate the required <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> fields for an interrupt transfer.  <a href="#ga90f53cea1124a7566df1aa1202b77510">More...</a><br /></td></tr>
<tr class="separator:ga90f53cea1124a7566df1aa1202b77510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30fdce8c461e851f0aa4c851014e1aa7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#ga30fdce8c461e851f0aa4c851014e1aa7">libusb_fill_iso_transfer</a> (struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *transfer, <a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle, unsigned char endpoint, unsigned char *buffer, int length, int num_iso_packets, <a class="el" href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a> callback, void *user_data, unsigned int timeout)</td></tr>
<tr class="memdesc:ga30fdce8c461e851f0aa4c851014e1aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to populate the required <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> fields for an isochronous transfer.  <a href="#ga30fdce8c461e851f0aa4c851014e1aa7">More...</a><br /></td></tr>
<tr class="separator:ga30fdce8c461e851f0aa4c851014e1aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbdecd6f50093f0c1d0e72ee35ace274"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#gacbdecd6f50093f0c1d0e72ee35ace274">libusb_set_iso_packet_lengths</a> (struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *transfer, unsigned int length)</td></tr>
<tr class="memdesc:gacbdecd6f50093f0c1d0e72ee35ace274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to set the length of all packets in an isochronous transfer, based on the num_iso_packets field in the transfer structure.  <a href="#gacbdecd6f50093f0c1d0e72ee35ace274">More...</a><br /></td></tr>
<tr class="separator:gacbdecd6f50093f0c1d0e72ee35ace274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f6ea0eb35a216d19d984977e454a7b3"><td class="memItemLeft" align="right" valign="top">static unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#ga7f6ea0eb35a216d19d984977e454a7b3">libusb_get_iso_packet_buffer</a> (struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *transfer, unsigned int packet)</td></tr>
<tr class="memdesc:ga7f6ea0eb35a216d19d984977e454a7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to locate the position of an isochronous packet within the buffer of an isochronous transfer.  <a href="#ga7f6ea0eb35a216d19d984977e454a7b3">More...</a><br /></td></tr>
<tr class="separator:ga7f6ea0eb35a216d19d984977e454a7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3df9a28c4f5c8f1850181ddb5efd12fd"><td class="memItemLeft" align="right" valign="top">static unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libusb__asyncio.html#ga3df9a28c4f5c8f1850181ddb5efd12fd">libusb_get_iso_packet_buffer_simple</a> (struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *transfer, unsigned int packet)</td></tr>
<tr class="memdesc:ga3df9a28c4f5c8f1850181ddb5efd12fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to locate the position of an isochronous packet within the buffer of an isochronous transfer, for transfers where each packet is of identical size.  <a href="#ga3df9a28c4f5c8f1850181ddb5efd12fd">More...</a><br /></td></tr>
<tr class="separator:ga3df9a28c4f5c8f1850181ddb5efd12fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This page details libusb's asynchronous (non-blocking) API for USB device I/O. </p>
<p>This interface is very powerful but is also quite complex - you will need to read this page carefully to understand the necessary considerations and issues surrounding use of this interface. Simplistic applications may wish to consider the <a class="el" href="group__libusb__syncio.html">synchronous I/O API</a> instead.</p>
<p>The asynchronous interface is built around the idea of separating transfer submission and handling of transfer completion (the synchronous model combines both of these into one). There may be a long delay between submission and completion, however the asynchronous submission function is non-blocking so will return control to your application during that potentially long delay.</p>
<h1><a class="anchor" id="asyncabstraction"></a>
Transfer abstraction</h1>
<p>For the asynchronous I/O, libusb implements the concept of a generic transfer entity for all types of I/O (control, bulk, interrupt, isochronous). The generic transfer object must be treated slightly differently depending on which type of I/O you are performing with it.</p>
<p>This is represented by the public <a class="el" href="structlibusb__transfer.html" title="The generic USB transfer structure. ">libusb_transfer</a> structure type.</p>
<h1><a class="anchor" id="asynctrf"></a>
Asynchronous transfers</h1>
<p>We can view asynchronous I/O as a 5 step process:</p><ol type="1">
<li><b>Allocation</b>: allocate a <a class="el" href="structlibusb__transfer.html" title="The generic USB transfer structure. ">libusb_transfer</a></li>
<li><b>Filling</b>: populate the <a class="el" href="structlibusb__transfer.html" title="The generic USB transfer structure. ">libusb_transfer</a> instance with information about the transfer you wish to perform</li>
<li><b>Submission</b>: ask libusb to submit the transfer</li>
<li><b>Completion handling</b>: examine transfer results in the <a class="el" href="structlibusb__transfer.html" title="The generic USB transfer structure. ">libusb_transfer</a> structure</li>
<li><b>Deallocation</b>: clean up resources</li>
</ol>
<h2><a class="anchor" id="asyncalloc"></a>
Allocation</h2>
<p>This step involves allocating memory for a USB transfer. This is the generic transfer object mentioned above. At this stage, the transfer is "blank" with no details about what type of I/O it will be used for.</p>
<p>Allocation is done with the <a class="el" href="group__libusb__asyncio.html#ga13cc69ea40c702181c430c950121c000" title="Allocate a libusb transfer with a specified number of isochronous packet descriptors. ">libusb_alloc_transfer()</a> function. You must use this function rather than allocating your own transfers.</p>
<h2><a class="anchor" id="asyncfill"></a>
Filling</h2>
<p>This step is where you take a previously allocated transfer and fill it with information to determine the message type and direction, data buffer, callback function, etc.</p>
<p>You can either fill the required fields yourself or you can use the helper functions: <a class="el" href="group__libusb__asyncio.html#ga3a8513ed87229fe2c9771ef0bf17206e" title="Helper function to populate the required libusb_transfer fields for a control transfer. ">libusb_fill_control_transfer()</a>, <a class="el" href="group__libusb__asyncio.html#gad4ddb1a5c6c7fefc979a44d7300b95d7" title="Helper function to populate the required libusb_transfer fields for a bulk transfer. ">libusb_fill_bulk_transfer()</a> and <a class="el" href="group__libusb__asyncio.html#ga90f53cea1124a7566df1aa1202b77510" title="Helper function to populate the required libusb_transfer fields for an interrupt transfer. ">libusb_fill_interrupt_transfer()</a>.</p>
<h2><a class="anchor" id="asyncsubmit"></a>
Submission</h2>
<p>When you have allocated a transfer and filled it, you can submit it using <a class="el" href="group__libusb__asyncio.html#gabb0932601f2c7dad2fee4b27962848ce" title="Submit a transfer. ">libusb_submit_transfer()</a>. This function returns immediately but can be regarded as firing off the I/O request in the background.</p>
<h2><a class="anchor" id="asynccomplete"></a>
Completion handling</h2>
<p>After a transfer has been submitted, one of four things can happen to it:</p>
<ul>
<li>The transfer completes (i.e. some data was transferred)</li>
<li>The transfer has a timeout and the timeout expires before all data is transferred</li>
<li>The transfer fails due to an error</li>
<li>The transfer is cancelled</li>
</ul>
<p>Each of these will cause the user-specified transfer callback function to be invoked. It is up to the callback function to determine which of the above actually happened and to act accordingly.</p>
<p>The user-specified callback is passed a pointer to the <a class="el" href="structlibusb__transfer.html" title="The generic USB transfer structure. ">libusb_transfer</a> structure which was used to setup and submit the transfer. At completion time, libusb has populated this structure with results of the transfer: success or failure reason, number of bytes of data transferred, etc. See the <a class="el" href="structlibusb__transfer.html" title="The generic USB transfer structure. ">libusb_transfer</a> structure documentation for more information.</p>
<p><b>Important Note</b>: The user-specified callback is called from an event handling context. It is therefore important that no calls are made into libusb that will attempt to perform any event handling. Examples of such functions are any listed in the <a class="el" href="group__libusb__syncio.html">synchronous API</a> and any of the blocking functions that retrieve <a class="el" href="group__libusb__desc.html">USB descriptors</a>.</p>
<h2><a class="anchor" id="Deallocation"></a>
Deallocation</h2>
<p>When a transfer has completed (i.e. the callback function has been invoked), you are advised to free the transfer (unless you wish to resubmit it, see below). Transfers are deallocated with <a class="el" href="group__libusb__asyncio.html#ga6ab8b2cff4de9091298a06b2f4b86cd6" title="Free a transfer structure. ">libusb_free_transfer()</a>.</p>
<p>It is undefined behaviour to free a transfer which has not completed.</p>
<h1><a class="anchor" id="asyncresubmit"></a>
Resubmission</h1>
<p>You may be wondering why allocation, filling, and submission are all separated above where they could reasonably be combined into a single operation.</p>
<p>The reason for separation is to allow you to resubmit transfers without having to allocate new ones every time. This is especially useful for common situations dealing with interrupt endpoints - you allocate one transfer, fill and submit it, and when it returns with results you just resubmit it for the next interrupt.</p>
<h1><a class="anchor" id="asynccancel"></a>
Cancellation</h1>
<p>Another advantage of using the asynchronous interface is that you have the ability to cancel transfers which have not yet completed. This is done by calling the <a class="el" href="group__libusb__asyncio.html#ga685eb7731f9a0593f75beb99727bbe54" title="Asynchronously cancel a previously submitted transfer. ">libusb_cancel_transfer()</a> function.</p>
<p><a class="el" href="group__libusb__asyncio.html#ga685eb7731f9a0593f75beb99727bbe54" title="Asynchronously cancel a previously submitted transfer. ">libusb_cancel_transfer()</a> is asynchronous/non-blocking in itself. When the cancellation actually completes, the transfer's callback function will be invoked, and the callback function should check the transfer status to determine that it was cancelled.</p>
<p>Freeing the transfer after it has been cancelled but before cancellation has completed will result in undefined behaviour.</p>
<p>When a transfer is cancelled, some of the data may have been transferred. libusb will communicate this to you in the transfer callback. Do not assume that no data was transferred.</p>
<h1><a class="anchor" id="bulk_overflows"></a>
Overflows on device-to-host bulk/interrupt endpoints</h1>
<p>If your device does not have predictable transfer sizes (or it misbehaves), your application may submit a request for data on an IN endpoint which is smaller than the data that the device wishes to send. In some circumstances this will cause an overflow, which is a nasty condition to deal with. See the <a class="el" href="libusb_packetoverflow.html">Packets and overflows</a> page for discussion.</p>
<h1><a class="anchor" id="asyncctrl"></a>
Considerations for control transfers</h1>
<p>The <code><a class="el" href="structlibusb__transfer.html" title="The generic USB transfer structure. ">libusb_transfer</a></code> structure is generic and hence does not include specific fields for the control-specific setup packet structure.</p>
<p>In order to perform a control transfer, you must place the 8-byte setup packet at the start of the data buffer. To simplify this, you could cast the buffer pointer to type struct <a class="el" href="structlibusb__control__setup.html" title="Setup packet for control transfers. ">libusb_control_setup</a>, or you can use the helper function <a class="el" href="group__libusb__asyncio.html#ga5447311149ec2bd954b5f1a640a8e231" title="Helper function to populate the setup packet (first 8 bytes of the data buffer) for a control transfe...">libusb_fill_control_setup()</a>.</p>
<p>The wLength field placed in the setup packet must be the length you would expect to be sent in the setup packet: the length of the payload that follows (or the expected maximum number of bytes to receive). However, the length field of the <a class="el" href="structlibusb__transfer.html" title="The generic USB transfer structure. ">libusb_transfer</a> object must be the length of the data buffer - i.e. it should be wLength <em>plus</em> the size of the setup packet (LIBUSB_CONTROL_SETUP_SIZE).</p>
<p>If you use the helper functions, this is simplified for you:</p><ol type="1">
<li>Allocate a buffer of size LIBUSB_CONTROL_SETUP_SIZE plus the size of the data you are sending/requesting.</li>
<li>Call <a class="el" href="group__libusb__asyncio.html#ga5447311149ec2bd954b5f1a640a8e231" title="Helper function to populate the setup packet (first 8 bytes of the data buffer) for a control transfe...">libusb_fill_control_setup()</a> on the data buffer, using the transfer request size as the wLength value (i.e. do not include the extra space you allocated for the control setup).</li>
<li>If this is a host-to-device transfer, place the data to be transferred in the data buffer, starting at offset LIBUSB_CONTROL_SETUP_SIZE.</li>
<li>Call <a class="el" href="group__libusb__asyncio.html#ga3a8513ed87229fe2c9771ef0bf17206e" title="Helper function to populate the required libusb_transfer fields for a control transfer. ">libusb_fill_control_transfer()</a> to associate the data buffer with the transfer (and to set the remaining details such as callback and timeout).<ul>
<li>Note that there is no parameter to set the length field of the transfer. The length is automatically inferred from the wLength field of the setup packet.</li>
</ul>
</li>
<li>Submit the transfer.</li>
</ol>
<p>The multi-byte control setup fields (wValue, wIndex and wLength) must be given in little-endian byte order (the endianness of the USB bus). Endianness conversion is transparently handled by <a class="el" href="group__libusb__asyncio.html#ga5447311149ec2bd954b5f1a640a8e231" title="Helper function to populate the setup packet (first 8 bytes of the data buffer) for a control transfe...">libusb_fill_control_setup()</a> which is documented to accept host-endian values.</p>
<p>Further considerations are needed when handling transfer completion in your callback function:</p><ul>
<li>As you might expect, the setup packet will still be sitting at the start of the data buffer.</li>
<li>If this was a device-to-host transfer, the received data will be sitting at offset LIBUSB_CONTROL_SETUP_SIZE into the buffer.</li>
<li>The actual_length field of the transfer structure is relative to the wLength of the setup packet, rather than the size of the data buffer. So, if your wLength was 4, your transfer's <code>length</code> was 12, then you should expect an <code>actual_length</code> of 4 to indicate that the data was transferred in entirity.</li>
</ul>
<p>To simplify parsing of setup packets and obtaining the data from the correct offset, you may wish to use the <a class="el" href="group__libusb__asyncio.html#gadf9c633586dde54ce62a3d66a4d7554c" title="Get the data section of a control transfer. ">libusb_control_transfer_get_data()</a> and <a class="el" href="group__libusb__asyncio.html#ga6ab02f15e11b5b03b1174fbd7c3bc061" title="Get the control setup packet of a control transfer. ">libusb_control_transfer_get_setup()</a> functions within your transfer callback.</p>
<p>Even though control endpoints do not halt, a completed control transfer may have a LIBUSB_TRANSFER_STALL status code. This indicates the control request was not supported.</p>
<h1><a class="anchor" id="asyncintr"></a>
Considerations for interrupt transfers</h1>
<p>All interrupt transfers are performed using the polling interval presented by the bInterval value of the endpoint descriptor.</p>
<h1><a class="anchor" id="asynciso"></a>
Considerations for isochronous transfers</h1>
<p>Isochronous transfers are more complicated than transfers to non-isochronous endpoints.</p>
<p>To perform I/O to an isochronous endpoint, allocate the transfer by calling <a class="el" href="group__libusb__asyncio.html#ga13cc69ea40c702181c430c950121c000" title="Allocate a libusb transfer with a specified number of isochronous packet descriptors. ">libusb_alloc_transfer()</a> with an appropriate number of isochronous packets.</p>
<p>During filling, set <a class="el" href="structlibusb__transfer.html#a7c9fa575986fe9f23bbecb26b766dff1">type</a> to <a class="el" href="group__libusb__desc.html#ggacb52027036a07de6ecc6c2bf07d07c71a40de9889554fc1785d784b3c31333300">LIBUSB_TRANSFER_TYPE_ISOCHRONOUS</a>, and set <a class="el" href="structlibusb__transfer.html#a87d725a5521c26832fdc13611220014d">num_iso_packets</a> to a value less than or equal to the number of packets you requested during allocation. <a class="el" href="group__libusb__asyncio.html#ga13cc69ea40c702181c430c950121c000" title="Allocate a libusb transfer with a specified number of isochronous packet descriptors. ">libusb_alloc_transfer()</a> does not set either of these fields for you, given that you might not even use the transfer on an isochronous endpoint.</p>
<p>Next, populate the length field for the first num_iso_packets entries in the <a class="el" href="structlibusb__transfer.html#a3b72ef736d32b94a7097798612741644">iso_packet_desc</a> array. Section 5.6.3 of the USB2 specifications describe how the maximum isochronous packet length is determined by the wMaxPacketSize field in the endpoint descriptor. Two functions can help you here:</p>
<ul>
<li><a class="el" href="group__libusb__dev.html#gaec10b71c7209760db55ee0f8768bb4f0" title="Calculate the maximum packet size which a specific endpoint is capable is sending or receiving in the...">libusb_get_max_iso_packet_size()</a> is an easy way to determine the max packet size for an isochronous endpoint. Note that the maximum packet size is actually the maximum number of bytes that can be transmitted in a single microframe, therefore this function multiplies the maximum number of bytes per transaction by the number of transaction opportunities per microframe.</li>
<li><a class="el" href="group__libusb__asyncio.html#gacbdecd6f50093f0c1d0e72ee35ace274" title="Convenience function to set the length of all packets in an isochronous transfer, based on the num_is...">libusb_set_iso_packet_lengths()</a> assigns the same length to all packets within a transfer, which is usually what you want.</li>
</ul>
<p>For outgoing transfers, you'll obviously fill the buffer and populate the packet descriptors in hope that all the data gets transferred. For incoming transfers, you must ensure the buffer has sufficient capacity for the situation where all packets transfer the full amount of requested data.</p>
<p>Completion handling requires some extra consideration. The <a class="el" href="structlibusb__transfer.html#a7e858f07c48a271a62209d11376ae607">actual_length</a> field of the transfer is meaningless and should not be examined; instead you must refer to the <a class="el" href="structlibusb__iso__packet__descriptor.html#a03fa4f4eaf8a8b4e5c05931809581a32">actual_length</a> field of each individual packet.</p>
<p>The <a class="el" href="structlibusb__transfer.html#a64b2e70e76d52a7cd23daa3cd4fb397e">status</a> field of the transfer is also a little misleading:</p><ul>
<li>If the packets were submitted and the isochronous data microframes completed normally, status will have value <a class="el" href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856a4595f6532aab12352a58a0fd4ce48363">LIBUSB_TRANSFER_COMPLETED</a>. Note that bus errors and software-incurred delays are not counted as transfer errors; the transfer.status field may indicate COMPLETED even if some or all of the packets failed. Refer to the <a class="el" href="structlibusb__iso__packet__descriptor.html#aab21ee2a5835a0e53d7ac5844ee34371">status</a> field of each individual packet to determine packet failures.</li>
<li>The status field will have value <a class="el" href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856aa8852ed719d03c2a3cc6f0312d919398">LIBUSB_TRANSFER_ERROR</a> only when serious errors were encountered.</li>
<li>Other transfer status codes occur with normal behaviour.</li>
</ul>
<p>The data for each packet will be found at an offset into the buffer that can be calculated as if each prior packet completed in full. The <a class="el" href="group__libusb__asyncio.html#ga7f6ea0eb35a216d19d984977e454a7b3" title="Convenience function to locate the position of an isochronous packet within the buffer of an isochron...">libusb_get_iso_packet_buffer()</a> and <a class="el" href="group__libusb__asyncio.html#ga3df9a28c4f5c8f1850181ddb5efd12fd" title="Convenience function to locate the position of an isochronous packet within the buffer of an isochron...">libusb_get_iso_packet_buffer_simple()</a> functions may help you here.</p>
<p><b>Note</b>: Some operating systems (e.g. Linux) may impose limits on the length of individual isochronous packets and/or the total length of the isochronous transfer. Such limits can be difficult for libusb to detect, so the library will simply try and submit the transfer as set up by you. If the transfer fails to submit because it is too large, <a class="el" href="group__libusb__asyncio.html#gabb0932601f2c7dad2fee4b27962848ce" title="Submit a transfer. ">libusb_submit_transfer()</a> will return <a class="el" href="group__libusb__misc.html#ggab2323aa0f04bc22038e7e1740b2f29efa680e4bf39b66a36be3182be3ebf58062">LIBUSB_ERROR_INVALID_PARAM</a>.</p>
<h1><a class="anchor" id="asyncmem"></a>
Memory caveats</h1>
<p>In most circumstances, it is not safe to use stack memory for transfer buffers. This is because the function that fired off the asynchronous transfer may return before libusb has finished using the buffer, and when the function returns it's stack gets destroyed. This is true for both host-to-device and device-to-host transfers.</p>
<p>The only case in which it is safe to use stack memory is where you can guarantee that the function owning the stack space for the buffer does not return until after the transfer's callback function has completed. In every other case, you need to use heap memory instead.</p>
<h1><a class="anchor" id="asyncflags"></a>
Fine control</h1>
<p>Through using this asynchronous interface, you may find yourself repeating a few simple operations many times. You can apply a bitwise OR of certain flags to a transfer to simplify certain things:</p><ul>
<li><a class="el" href="group__libusb__asyncio.html#gga1fb47dd0f7c209b60a3609ff0c03d56dae4c0697c266819c51c1734b3456e7276">LIBUSB_TRANSFER_SHORT_NOT_OK</a> results in transfers which transferred less than the requested amount of data being marked with status <a class="el" href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856aa8852ed719d03c2a3cc6f0312d919398">LIBUSB_TRANSFER_ERROR</a> (they would normally be regarded as COMPLETED)</li>
<li><a class="el" href="group__libusb__asyncio.html#gga1fb47dd0f7c209b60a3609ff0c03d56dae993a26f495ac9949118e23eafa19e86">LIBUSB_TRANSFER_FREE_BUFFER</a> allows you to ask libusb to free the transfer buffer when freeing the transfer.</li>
<li><a class="el" href="group__libusb__asyncio.html#gga1fb47dd0f7c209b60a3609ff0c03d56dacf3f064997b283a14097c9f4d6f8ccc1">LIBUSB_TRANSFER_FREE_TRANSFER</a> causes libusb to automatically free the transfer after the transfer callback returns.</li>
</ul>
<h1><a class="anchor" id="asyncevent"></a>
Event handling</h1>
<p>An asynchronous model requires that libusb perform work at various points in time - namely processing the results of previously-submitted transfers and invoking the user-supplied callback function.</p>
<p>This gives rise to the <a class="el" href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327" title="Handle any pending events in blocking mode. ">libusb_handle_events()</a> function which your application must call into when libusb has work do to. This gives libusb the opportunity to reap pending transfers, invoke callbacks, etc.</p>
<p>There are 2 different approaches to dealing with libusb_handle_events:</p>
<ol type="1">
<li>Repeatedly call <a class="el" href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327" title="Handle any pending events in blocking mode. ">libusb_handle_events()</a> in blocking mode from a dedicated thread.</li>
<li>Integrate libusb with your application's main event loop. libusb exposes a set of file descriptors which allow you to do this.</li>
</ol>
<p>The first approach has the big advantage that it will also work on Windows were libusb' poll API for select / poll integration is not available. So if you want to support Windows and use the async API, you must use this approach, see the <a class="el" href="group__libusb__asyncio.html#eventthread">Using an event handling thread</a> section below for details.</p>
<p>If you prefer a single threaded approach with a single central event loop, see the <a class="el" href="group__libusb__poll.html">polling and timing</a> section for how to integrate libusb into your application's main event loop.</p>
<h1><a class="anchor" id="eventthread"></a>
Using an event handling thread</h1>
<p>Lets begin with stating the obvious: If you're going to use a separate thread for libusb event handling, your callback functions MUST be threadsafe.</p>
<p>Other then that doing event handling from a separate thread, is mostly simple. You can use an event thread function as follows: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> *event_thread_func(<span class="keywordtype">void</span> *ctx)</div><div class="line">{</div><div class="line">    <span class="keywordflow">while</span> (event_thread_run)</div><div class="line">        <a class="code" href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events</a>(ctx);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> NULL;</div><div class="line">}</div></div><!-- fragment --><p>There is one caveat though, stopping this thread requires setting the event_thread_run variable to 0, and after that <a class="el" href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327" title="Handle any pending events in blocking mode. ">libusb_handle_events()</a> needs to return control to event_thread_func. But unless some event happens, <a class="el" href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327" title="Handle any pending events in blocking mode. ">libusb_handle_events()</a> will not return.</p>
<p>There are 2 different ways of dealing with this, depending on if your application uses libusb' <a class="el" href="libusb_hotplug.html">hotplug</a> support or not.</p>
<p>Applications which do not use hotplug support, should not start the event thread until after their first call to <a class="el" href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0" title="Open a device and obtain a device handle. ">libusb_open()</a>, and should stop the thread when closing the last open device as follows: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_close_handle(<a class="code" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *dev_handle)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (open_devs == 1)</div><div class="line">        event_thread_run = 0;</div><div class="line"></div><div class="line">    <a class="code" href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close</a>(dev_handle); <span class="comment">// This wakes up libusb_handle_events()</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (open_devs == 1)</div><div class="line">        pthread_join(event_thread);</div><div class="line"></div><div class="line">    open_devs--;</div><div class="line">}</div></div><!-- fragment --><p>Applications using hotplug support should start the thread at program init, after having successfully called <a class="el" href="group__libusb__hotplug.html#ga00e0c69ddf1fb1b6774dc918192e8dc7" title="Register a hotplug callback function. ">libusb_hotplug_register_callback()</a>, and should stop the thread at program exit as follows: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_libusb_exit(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    event_thread_run = 0;</div><div class="line">    <a class="code" href="group__libusb__hotplug.html#ga8110f57eab2064375934f1449b2602bc">libusb_hotplug_deregister_callback</a>(ctx, hotplug_cb_handle); <span class="comment">// This wakes up libusb_handle_events()</span></div><div class="line">    pthread_join(event_thread);</div><div class="line">    <a class="code" href="group__libusb__lib.html#ga86532f222d4f1332a5f8f5eef9a92da9">libusb_exit</a>(ctx);</div><div class="line">}</div></div><!-- fragment --> <h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gac74874519794cd7aa40c0814702b0c88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( * libusb_transfer_cb_fn) (struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *transfer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous transfer callback function type. </p>
<p>When submitting asynchronous transfers, you pass a pointer to a callback function of this type via the <a class="el" href="structlibusb__transfer.html#a69c6df011ec23ff3e481cc98bfff0623">callback</a> member of the <a class="el" href="structlibusb__transfer.html" title="The generic USB transfer structure. ">libusb_transfer</a> structure. libusb will call this function later, when the transfer has completed or failed. See <a class="el" href="group__libusb__asyncio.html">Asynchronous device I/O</a> for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>The <a class="el" href="structlibusb__transfer.html" title="The generic USB transfer structure. ">libusb_transfer</a> struct the callback function is being notified about. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga9fcb2aa23d342060ebda1d0cf7478856"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__libusb__asyncio.html#ga9fcb2aa23d342060ebda1d0cf7478856">libusb_transfer_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer status codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga9fcb2aa23d342060ebda1d0cf7478856a4595f6532aab12352a58a0fd4ce48363"></a>LIBUSB_TRANSFER_COMPLETED&#160;</td><td class="fielddoc">
<p>Transfer completed without error. </p>
<p>Note that this does not indicate that the entire amount of requested data was transferred. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9fcb2aa23d342060ebda1d0cf7478856aa8852ed719d03c2a3cc6f0312d919398"></a>LIBUSB_TRANSFER_ERROR&#160;</td><td class="fielddoc">
<p>Transfer failed. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9fcb2aa23d342060ebda1d0cf7478856ac2b7626d7b51cb980f83933b6ada1ddf"></a>LIBUSB_TRANSFER_TIMED_OUT&#160;</td><td class="fielddoc">
<p>Transfer timed out. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9fcb2aa23d342060ebda1d0cf7478856a8af1f19e46cccafdcf3feadce47e880b"></a>LIBUSB_TRANSFER_CANCELLED&#160;</td><td class="fielddoc">
<p>Transfer was cancelled. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9fcb2aa23d342060ebda1d0cf7478856a23cdfd929f5fe82cca9654f8075eeebb"></a>LIBUSB_TRANSFER_STALL&#160;</td><td class="fielddoc">
<p>For bulk/interrupt endpoints: halt condition detected (endpoint stalled). </p>
<p>For control endpoints: control request not supported. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9fcb2aa23d342060ebda1d0cf7478856ab7dcb24f313ace407e0c070d6b2c5f13"></a>LIBUSB_TRANSFER_NO_DEVICE&#160;</td><td class="fielddoc">
<p>Device was disconnected. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9fcb2aa23d342060ebda1d0cf7478856ab1b9cbcb1de27a8fbeceb3427fb2fb14"></a>LIBUSB_TRANSFER_OVERFLOW&#160;</td><td class="fielddoc">
<p>Device sent more data than requested. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga1fb47dd0f7c209b60a3609ff0c03d56d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__libusb__asyncio.html#ga1fb47dd0f7c209b60a3609ff0c03d56d">libusb_transfer_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structlibusb__transfer.html#ae26c063df30c2e29835212aad98c6e06" title="A bitwise OR combination of libusb_transfer_flags. ">libusb_transfer.flags</a> values </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga1fb47dd0f7c209b60a3609ff0c03d56dae4c0697c266819c51c1734b3456e7276"></a>LIBUSB_TRANSFER_SHORT_NOT_OK&#160;</td><td class="fielddoc">
<p>Report short frames as errors. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1fb47dd0f7c209b60a3609ff0c03d56dae993a26f495ac9949118e23eafa19e86"></a>LIBUSB_TRANSFER_FREE_BUFFER&#160;</td><td class="fielddoc">
<p>Automatically free() transfer buffer during <a class="el" href="group__libusb__asyncio.html#ga6ab8b2cff4de9091298a06b2f4b86cd6" title="Free a transfer structure. ">libusb_free_transfer()</a>. </p>
<p>Note that buffers allocated with <a class="el" href="group__libusb__asyncio.html#ga47c492e750197f1a28874c7a0dee40e3" title="Attempts to allocate a block of persistent DMA memory suitable for transfers against the given device...">libusb_dev_mem_alloc()</a> should not be attempted freed in this way, since free() is not an appropriate way to release such memory. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1fb47dd0f7c209b60a3609ff0c03d56dacf3f064997b283a14097c9f4d6f8ccc1"></a>LIBUSB_TRANSFER_FREE_TRANSFER&#160;</td><td class="fielddoc">
<p>Automatically call <a class="el" href="group__libusb__asyncio.html#ga6ab8b2cff4de9091298a06b2f4b86cd6" title="Free a transfer structure. ">libusb_free_transfer()</a> after callback returns. </p>
<p>If this flag is set, it is illegal to call <a class="el" href="group__libusb__asyncio.html#ga6ab8b2cff4de9091298a06b2f4b86cd6" title="Free a transfer structure. ">libusb_free_transfer()</a> from your transfer callback, as this will result in a double-free when this flag is acted upon. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1fb47dd0f7c209b60a3609ff0c03d56da26b66334b6ec0537c49841ca623d901f"></a>LIBUSB_TRANSFER_ADD_ZERO_PACKET&#160;</td><td class="fielddoc">
<p>Terminate transfers that are a multiple of the endpoint's wMaxPacketSize with an extra zero length packet. </p>
<p>This is useful when a device protocol mandates that each logical request is terminated by an incomplete packet (i.e. the logical requests are not separated by other means).</p>
<p>This flag only affects host-to-device transfers to bulk and interrupt endpoints. In other situations, it is ignored.</p>
<p>This flag only affects transfers with a length that is a multiple of the endpoint's wMaxPacketSize. On transfers of other lengths, this flag has no effect. Therefore, if you are working with a device that needs a ZLP whenever the end of the logical request falls on a packet boundary, then it is sensible to set this flag on <em>every</em> transfer (you do not have to worry about only setting it on transfers that end on the boundary).</p>
<p>This flag is currently only supported on Linux. On other systems, <a class="el" href="group__libusb__asyncio.html#gabb0932601f2c7dad2fee4b27962848ce" title="Submit a transfer. ">libusb_submit_transfer()</a> will return LIBUSB_ERROR_NOT_SUPPORTED for every transfer where this flag is set.</p>
<p>Available since libusb-1.0.9. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad7e786c1bedd4a668887564465101981"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_alloc_streams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_endpoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate up to num_streams usb bulk streams on the specified endpoints. </p>
<p>This function takes an array of endpoints rather then a single endpoint because some protocols require that endpoints are setup with similar stream ids. All endpoints passed in must belong to the same interface.</p>
<p>Note this function may return less streams then requested. Also note that the same number of streams are allocated for each endpoint in the endpoint array.</p>
<p>Stream id 0 is reserved, and should not be used to communicate with devices. If <a class="el" href="group__libusb__asyncio.html#gad7e786c1bedd4a668887564465101981" title="Allocate up to num_streams usb bulk streams on the specified endpoints. ">libusb_alloc_streams()</a> returns with a value of N, you may use stream ids 1 to N.</p>
<p>Since version 1.0.19, <a class="el" href="group__libusb__misc.html#gaabe4bc36a83358685d36a6c853cbb4de">LIBUSB_API_VERSION</a> &gt;= 0x01000103</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">num_streams</td><td>number of streams to try to allocate </td></tr>
    <tr><td class="paramname">endpoints</td><td>array of endpoints to allocate streams on </td></tr>
    <tr><td class="paramname">num_endpoints</td><td>length of the endpoints array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of streams allocated, or a LIBUSB_ERROR code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="gab068de0fd203ccef5c620a8143526acb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_free_streams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_endpoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free usb bulk streams allocated with <a class="el" href="group__libusb__asyncio.html#gad7e786c1bedd4a668887564465101981" title="Allocate up to num_streams usb bulk streams on the specified endpoints. ">libusb_alloc_streams()</a>. </p>
<p>Note streams are automatically free-ed when releasing an interface.</p>
<p>Since version 1.0.19, <a class="el" href="group__libusb__misc.html#gaabe4bc36a83358685d36a6c853cbb4de">LIBUSB_API_VERSION</a> &gt;= 0x01000103</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">endpoints</td><td>array of endpoints to free streams on </td></tr>
    <tr><td class="paramname">num_endpoints</td><td>length of the endpoints array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LIBUSB_SUCCESS, or a LIBUSB_ERROR code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga47c492e750197f1a28874c7a0dee40e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* libusb_dev_mem_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to allocate a block of persistent DMA memory suitable for transfers against the given device. </p>
<p>If successful, will return a block of memory that is suitable for use as "buffer" in <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> against this device. Using this memory instead of regular memory means that the host controller can use DMA directly into the buffer to increase performance, and also that transfers can no longer fail due to kernel memory fragmentation.</p>
<p>Note that this means you should not modify this memory (or even data on the same cache lines) when a transfer is in progress, although it is legal to have several transfers going on within the same memory block.</p>
<p>Will return NULL on failure. Many systems do not support such zerocopy and will always return NULL. Memory allocated with this function must be freed with <a class="el" href="group__libusb__asyncio.html#gad7575ff325f0159a5b74b7c0ee64eb62">libusb_dev_mem_free</a>. Specifically, this means that the flag <a class="el" href="group__libusb__asyncio.html#gga1fb47dd0f7c209b60a3609ff0c03d56dae993a26f495ac9949118e23eafa19e86">LIBUSB_TRANSFER_FREE_BUFFER</a> cannot be used to free memory allocated with this function.</p>
<p>Since version 1.0.21, <a class="el" href="group__libusb__misc.html#gaabe4bc36a83358685d36a6c853cbb4de">LIBUSB_API_VERSION</a> &gt;= 0x01000105</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">length</td><td>size of desired data buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly allocated memory, or NULL on failure </dd></dl>

</div>
</div>
<a class="anchor" id="gad7575ff325f0159a5b74b7c0ee64eb62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_dev_mem_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free device memory allocated with <a class="el" href="group__libusb__asyncio.html#ga47c492e750197f1a28874c7a0dee40e3" title="Attempts to allocate a block of persistent DMA memory suitable for transfers against the given device...">libusb_dev_mem_alloc()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">buffer</td><td>pointer to the previously allocated memory </td></tr>
    <tr><td class="paramname">length</td><td>size of previously allocated memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LIBUSB_SUCCESS, or a LIBUSB_ERROR code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga13cc69ea40c702181c430c950121c000"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>* libusb_alloc_transfer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iso_packets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a libusb transfer with a specified number of isochronous packet descriptors. </p>
<p>The returned transfer is pre-initialized for you. When the new transfer is no longer needed, it should be freed with <a class="el" href="group__libusb__asyncio.html#ga6ab8b2cff4de9091298a06b2f4b86cd6" title="Free a transfer structure. ">libusb_free_transfer()</a>.</p>
<p>Transfers intended for non-isochronous endpoints (e.g. control, bulk, interrupt) should specify an iso_packets count of zero.</p>
<p>For transfers intended for isochronous endpoints, specify an appropriate number of packet descriptors to be allocated as part of the transfer. The returned transfer is not specially initialized for isochronous I/O; you are still required to set the <a class="el" href="structlibusb__transfer.html#a87d725a5521c26832fdc13611220014d">num_iso_packets</a> and <a class="el" href="structlibusb__transfer.html#a7c9fa575986fe9f23bbecb26b766dff1">type</a> fields accordingly.</p>
<p>It is safe to allocate a transfer with some isochronous packets and then use it on a non-isochronous endpoint. If you do this, ensure that at time of submission, num_iso_packets is 0 and that type is set appropriately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iso_packets</td><td>number of isochronous packet descriptors to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated transfer, or NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="ga6ab8b2cff4de9091298a06b2f4b86cd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libusb_free_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *&#160;</td>
          <td class="paramname"><em>transfer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a transfer structure. </p>
<p>This should be called for all transfers allocated with <a class="el" href="group__libusb__asyncio.html#ga13cc69ea40c702181c430c950121c000" title="Allocate a libusb transfer with a specified number of isochronous packet descriptors. ">libusb_alloc_transfer()</a>.</p>
<p>If the <a class="el" href="group__libusb__asyncio.html#gga1fb47dd0f7c209b60a3609ff0c03d56dae993a26f495ac9949118e23eafa19e86">LIBUSB_TRANSFER_FREE_BUFFER</a> flag is set and the transfer buffer is non-NULL, this function will also free the transfer buffer using the standard system memory allocator (e.g. free()).</p>
<p>It is legal to call this function with a NULL transfer. In this case, the function will simply return safely.</p>
<p>It is not legal to free an active transfer (one which has been submitted and has not yet completed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>the transfer to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabb0932601f2c7dad2fee4b27962848ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_submit_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *&#160;</td>
          <td class="paramname"><em>transfer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a transfer. </p>
<p>This function will fire off the USB transfer and then return immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>the transfer to submit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
LIBUSB_ERROR_BUSY if the transfer has already been submitted. </dd>
<dd>
LIBUSB_ERROR_NOT_SUPPORTED if the transfer flags are not supported by the operating system. </dd>
<dd>
LIBUSB_ERROR_INVALID_PARAM if the transfer size is larger than the operating system and/or hardware can support </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga685eb7731f9a0593f75beb99727bbe54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_cancel_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *&#160;</td>
          <td class="paramname"><em>transfer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously cancel a previously submitted transfer. </p>
<p>This function returns immediately, but this does not indicate cancellation is complete. Your callback function will be invoked at some later time with a transfer status of <a class="el" href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856a8af1f19e46cccafdcf3feadce47e880b">LIBUSB_TRANSFER_CANCELLED.</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>the transfer to cancel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if the transfer is not in progress, already complete, or already cancelled. </dd>
<dd>
a LIBUSB_ERROR code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="gaeae2db23b9de811af317483afdeb230f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libusb_transfer_set_stream_id </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stream_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a transfers bulk stream id. </p>
<p>Note users are advised to use <a class="el" href="group__libusb__asyncio.html#gac2e84d8fb9218d3c67e6a4fd4ade5b10" title="Helper function to populate the required libusb_transfer fields for a bulk transfer using bulk stream...">libusb_fill_bulk_stream_transfer()</a> instead of calling this function directly.</p>
<p>Since version 1.0.19, <a class="el" href="group__libusb__misc.html#gaabe4bc36a83358685d36a6c853cbb4de">LIBUSB_API_VERSION</a> &gt;= 0x01000103</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>the transfer to set the stream id for </td></tr>
    <tr><td class="paramname">stream_id</td><td>the stream id to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libusb__asyncio.html#gad7e786c1bedd4a668887564465101981" title="Allocate up to num_streams usb bulk streams on the specified endpoints. ">libusb_alloc_streams()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga631653487273f3306925131cdc0a3ffc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t libusb_transfer_get_stream_id </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *&#160;</td>
          <td class="paramname"><em>transfer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a transfers bulk stream id. </p>
<p>Since version 1.0.19, <a class="el" href="group__libusb__misc.html#gaabe4bc36a83358685d36a6c853cbb4de">LIBUSB_API_VERSION</a> &gt;= 0x01000103</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>the transfer to get the stream id for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the stream id for the transfer </dd></dl>

</div>
</div>
<a class="anchor" id="gadf9c633586dde54ce62a3d66a4d7554c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned char* libusb_control_transfer_get_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *&#160;</td>
          <td class="paramname"><em>transfer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the data section of a control transfer. </p>
<p>This convenience function is here to remind you that the data does not start until 8 bytes into the actual buffer, as the setup packet comes first.</p>
<p>Calling this function only makes sense from a transfer callback function, or situations where you have already allocated a suitably sized buffer at transfer-&gt;buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>a transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first byte of the data section </dd></dl>

</div>
</div>
<a class="anchor" id="ga6ab02f15e11b5b03b1174fbd7c3bc061"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structlibusb__control__setup.html">libusb_control_setup</a>* libusb_control_transfer_get_setup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *&#160;</td>
          <td class="paramname"><em>transfer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the control setup packet of a control transfer. </p>
<p>This convenience function is here to remind you that the control setup occupies the first 8 bytes of the transfer data buffer.</p>
<p>Calling this function only makes sense from a transfer callback function, or situations where you have already allocated a suitably sized buffer at transfer-&gt;buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>a transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a casted pointer to the start of the transfer data buffer </dd></dl>

</div>
</div>
<a class="anchor" id="ga5447311149ec2bd954b5f1a640a8e231"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void libusb_fill_control_setup </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bmRequestType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to populate the setup packet (first 8 bytes of the data buffer) for a control transfer. </p>
<p>The wIndex, wValue and wLength values should be given in host-endian byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>buffer to output the setup packet into This pointer must be aligned to at least 2 bytes boundary. </td></tr>
    <tr><td class="paramname">bmRequestType</td><td>see the <a class="el" href="structlibusb__control__setup.html#a39b148c231d675492ccd2383196926bf">bmRequestType</a> field of <a class="el" href="structlibusb__control__setup.html">libusb_control_setup</a> </td></tr>
    <tr><td class="paramname">bRequest</td><td>see the <a class="el" href="structlibusb__control__setup.html#a1b80a28b8d4e8586fc54358194e70087">bRequest</a> field of <a class="el" href="structlibusb__control__setup.html">libusb_control_setup</a> </td></tr>
    <tr><td class="paramname">wValue</td><td>see the <a class="el" href="structlibusb__control__setup.html#abbb6daa01fe4b6a05dc43492e4e53a7d">wValue</a> field of <a class="el" href="structlibusb__control__setup.html">libusb_control_setup</a> </td></tr>
    <tr><td class="paramname">wIndex</td><td>see the <a class="el" href="structlibusb__control__setup.html#a70c2ae456344b200a19d434ace85ae2b">wIndex</a> field of <a class="el" href="structlibusb__control__setup.html">libusb_control_setup</a> </td></tr>
    <tr><td class="paramname">wLength</td><td>see the <a class="el" href="structlibusb__control__setup.html#a3c442c64fd7619b43b782367235766cc">wLength</a> field of <a class="el" href="structlibusb__control__setup.html">libusb_control_setup</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3a8513ed87229fe2c9771ef0bf17206e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void libusb_fill_control_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to populate the required <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> fields for a control transfer. </p>
<p>If you pass a transfer buffer to this function, the first 8 bytes will be interpreted as a control setup packet, and the wLength field will be used to automatically populate the <a class="el" href="structlibusb__transfer.html#a68c023e1f40b50aa8604a2495b6a391e">length</a> field of the transfer. Therefore the recommended approach is:</p><ol type="1">
<li>Allocate a suitably sized data buffer (including space for control setup)</li>
<li>Call <a class="el" href="group__libusb__asyncio.html#ga5447311149ec2bd954b5f1a640a8e231" title="Helper function to populate the setup packet (first 8 bytes of the data buffer) for a control transfe...">libusb_fill_control_setup()</a></li>
<li>If this is a host-to-device transfer with a data stage, put the data in place after the setup packet</li>
<li>Call this function</li>
<li>Call <a class="el" href="group__libusb__asyncio.html#gabb0932601f2c7dad2fee4b27962848ce" title="Submit a transfer. ">libusb_submit_transfer()</a></li>
</ol>
<p>It is also legal to pass a NULL buffer to this function, in which case this function will not attempt to populate the length field. Remember that you must then populate the buffer and length fields later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>the transfer to populate </td></tr>
    <tr><td class="paramname">dev_handle</td><td>handle of the device that will handle the transfer </td></tr>
    <tr><td class="paramname">buffer</td><td>data buffer. If provided, this function will interpret the first 8 bytes as a setup packet and infer the transfer length from that. This pointer must be aligned to at least 2 bytes boundary. </td></tr>
    <tr><td class="paramname">callback</td><td>callback function to be invoked on transfer completion </td></tr>
    <tr><td class="paramname">user_data</td><td>user data to pass to callback function </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout for the transfer in milliseconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad4ddb1a5c6c7fefc979a44d7300b95d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void libusb_fill_bulk_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to populate the required <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> fields for a bulk transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>the transfer to populate </td></tr>
    <tr><td class="paramname">dev_handle</td><td>handle of the device that will handle the transfer </td></tr>
    <tr><td class="paramname">endpoint</td><td>address of the endpoint where this transfer will be sent </td></tr>
    <tr><td class="paramname">buffer</td><td>data buffer </td></tr>
    <tr><td class="paramname">length</td><td>length of data buffer </td></tr>
    <tr><td class="paramname">callback</td><td>callback function to be invoked on transfer completion </td></tr>
    <tr><td class="paramname">user_data</td><td>user data to pass to callback function </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout for the transfer in milliseconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac2e84d8fb9218d3c67e6a4fd4ade5b10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void libusb_fill_bulk_stream_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stream_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to populate the required <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> fields for a bulk transfer using bulk streams. </p>
<p>Since version 1.0.19, <a class="el" href="group__libusb__misc.html#gaabe4bc36a83358685d36a6c853cbb4de">LIBUSB_API_VERSION</a> &gt;= 0x01000103</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>the transfer to populate </td></tr>
    <tr><td class="paramname">dev_handle</td><td>handle of the device that will handle the transfer </td></tr>
    <tr><td class="paramname">endpoint</td><td>address of the endpoint where this transfer will be sent </td></tr>
    <tr><td class="paramname">stream_id</td><td>bulk stream id for this transfer </td></tr>
    <tr><td class="paramname">buffer</td><td>data buffer </td></tr>
    <tr><td class="paramname">length</td><td>length of data buffer </td></tr>
    <tr><td class="paramname">callback</td><td>callback function to be invoked on transfer completion </td></tr>
    <tr><td class="paramname">user_data</td><td>user data to pass to callback function </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout for the transfer in milliseconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga90f53cea1124a7566df1aa1202b77510"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void libusb_fill_interrupt_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to populate the required <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> fields for an interrupt transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>the transfer to populate </td></tr>
    <tr><td class="paramname">dev_handle</td><td>handle of the device that will handle the transfer </td></tr>
    <tr><td class="paramname">endpoint</td><td>address of the endpoint where this transfer will be sent </td></tr>
    <tr><td class="paramname">buffer</td><td>data buffer </td></tr>
    <tr><td class="paramname">length</td><td>length of data buffer </td></tr>
    <tr><td class="paramname">callback</td><td>callback function to be invoked on transfer completion </td></tr>
    <tr><td class="paramname">user_data</td><td>user data to pass to callback function </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout for the transfer in milliseconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga30fdce8c461e851f0aa4c851014e1aa7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void libusb_fill_iso_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a> *&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_iso_packets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to populate the required <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> fields for an isochronous transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>the transfer to populate </td></tr>
    <tr><td class="paramname">dev_handle</td><td>handle of the device that will handle the transfer </td></tr>
    <tr><td class="paramname">endpoint</td><td>address of the endpoint where this transfer will be sent </td></tr>
    <tr><td class="paramname">buffer</td><td>data buffer </td></tr>
    <tr><td class="paramname">length</td><td>length of data buffer </td></tr>
    <tr><td class="paramname">num_iso_packets</td><td>the number of isochronous packets </td></tr>
    <tr><td class="paramname">callback</td><td>callback function to be invoked on transfer completion </td></tr>
    <tr><td class="paramname">user_data</td><td>user data to pass to callback function </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout for the transfer in milliseconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacbdecd6f50093f0c1d0e72ee35ace274"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void libusb_set_iso_packet_lengths </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to set the length of all packets in an isochronous transfer, based on the num_iso_packets field in the transfer structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>a transfer </td></tr>
    <tr><td class="paramname">length</td><td>the length to set in each isochronous packet descriptor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libusb__dev.html#gac81968047e262409e78f3fe24321b604" title="Convenience function to retrieve the wMaxPacketSize value for a particular endpoint in the active dev...">libusb_get_max_packet_size()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f6ea0eb35a216d19d984977e454a7b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned char* libusb_get_iso_packet_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to locate the position of an isochronous packet within the buffer of an isochronous transfer. </p>
<p>This is a thorough function which loops through all preceding packets, accumulating their lengths to find the position of the specified packet. Typically you will assign equal lengths to each packet in the transfer, and hence the above method is sub-optimal. You may wish to use <a class="el" href="group__libusb__asyncio.html#ga3df9a28c4f5c8f1850181ddb5efd12fd" title="Convenience function to locate the position of an isochronous packet within the buffer of an isochron...">libusb_get_iso_packet_buffer_simple()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>a transfer </td></tr>
    <tr><td class="paramname">packet</td><td>the packet to return the address of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the base address of the packet buffer inside the transfer buffer, or NULL if the packet does not exist. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libusb__asyncio.html#ga3df9a28c4f5c8f1850181ddb5efd12fd" title="Convenience function to locate the position of an isochronous packet within the buffer of an isochron...">libusb_get_iso_packet_buffer_simple()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3df9a28c4f5c8f1850181ddb5efd12fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned char* libusb_get_iso_packet_buffer_simple </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> *&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to locate the position of an isochronous packet within the buffer of an isochronous transfer, for transfers where each packet is of identical size. </p>
<p>This function relies on the assumption that every packet within the transfer is of identical size to the first packet. Calculating the location of the packet buffer is then just a simple calculation: <code>buffer + (packet_size * packet)</code></p>
<p>Do not use this function on transfers other than those that have identical packet lengths for each packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>a transfer </td></tr>
    <tr><td class="paramname">packet</td><td>the packet to return the address of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the base address of the packet buffer inside the transfer buffer, or NULL if the packet does not exist. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__libusb__asyncio.html#ga7f6ea0eb35a216d19d984977e454a7b3" title="Convenience function to locate the position of an isochronous packet within the buffer of an isochron...">libusb_get_iso_packet_buffer()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 24 2018 18:50:59 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
